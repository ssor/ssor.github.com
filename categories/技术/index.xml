<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on 我思故我在</title>
    <link>http://ssor.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml</link>
    <description>Recent content in 技术 on 我思故我在</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://ssor.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>提倡公司开源运动</title>
      <link>http://ssor.github.io/post/the_open_source_for_company/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/the_open_source_for_company/</guid>
      <description>&lt;p&gt;为什么要在公司技术管理上提倡开源, 如何开源
&lt;/p&gt;

&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;

&lt;p&gt;保证技术公司拥有强劲竞争力的方法是拥有一支高水平的技术团队.  打造这样高水平的团队有几个方法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;高水平的招聘&lt;/li&gt;
&lt;li&gt;自行培养&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个方法优点是直观简单,  但也有缺陷:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代价高昂&lt;/li&gt;
&lt;li&gt;很难招&lt;/li&gt;
&lt;li&gt;合作难&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;战略上来说第二种方法几乎没有第一种方法的缺点, 除了时间较长外, 显然更加最合适.&lt;/p&gt;

&lt;p&gt;那么应该如何培养呢? 这里有克服几个问题:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;什么是更好的技术人要客观, 不能几个人说了算, 评价标准必须客观&lt;/li&gt;
&lt;li&gt;不能敝帚自珍, 多接触圈内的高手才能意识到自己的不足和努力的方向, 才有可能提高自己的技术水平&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;怎么解决这些问题? 从外部请专家? 定期交流? 多参加技术交流大会? 这些方式不仅效率低, 效果也不是很好. 其实最好的方式就是开源.&lt;/p&gt;

&lt;h2 id=&#34;什么是开源&#34;&gt;什么是开源&lt;/h2&gt;

&lt;p&gt;开源不是简单的把自己的代码放到 GitHub 上, 让所有人都可以访问. 开源的目标是和所有人互动.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把自己的代码整理好, 包括代码和相关文档, 可以让其他人参与进项目本身&lt;/li&gt;
&lt;li&gt;参与别人的项目, 贡献自己的想法和代码&lt;/li&gt;
&lt;li&gt;多听取意见, 然后自己决定&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;开源的忧虑&#34;&gt;开源的忧虑&lt;/h2&gt;

&lt;p&gt;开源让很多公司的管理者产生很多忧虑:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果代码别人都知道了, 那竞争对手是不是就可以复制我, 然后和我竞争了?&lt;/li&gt;
&lt;li&gt;系统的漏洞是不是就暴露出来了? 这样会不会影响公司发展?&lt;/li&gt;
&lt;li&gt;团队搞开源, 放在业务上的精力变少了, 那公司还怎么发展?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;慢慢来解释这些问题.&lt;/p&gt;

&lt;h3 id=&#34;1-代码的开放&#34;&gt;1. 代码的开放&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;如果竞争对手只是把你的系统运转起来就能和你竞争, 那说明你的产品本身竞争力就不强&lt;/li&gt;
&lt;li&gt;即使没有你的代码, 人家一样和你竞争, 只要你的技术不是独一无二的, 就不存在什么大的门槛.&lt;/li&gt;
&lt;li&gt;让你时刻意识到公司的竞争力不在几行代码上, 而在产品和服务上, 认真做好产品和服务才是根本&lt;/li&gt;
&lt;li&gt;如果能吸引到公司外的人贡献代码, 那就等于有人免费为公司工作&lt;/li&gt;
&lt;li&gt;多个人多一条思路, 系统的功能和性能方面可能有意外的收获&lt;/li&gt;
&lt;li&gt;多人的参与, 正常情况下, 代码质量会更高&lt;/li&gt;
&lt;li&gt;如果有人离职了, 从代码贡献者里面直接找一个替代&lt;/li&gt;
&lt;li&gt;发现有人对部分代码特别感兴趣, 直接招聘他进公司&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2-为系统漏洞付出的代价更小&#34;&gt;2. 为系统漏洞付出的代价更小&lt;/h3&gt;

&lt;p&gt;如果系统本身存在漏洞, 黑客迟早会抓住这个机会. 如果能因为开放代码使得有人能提前提出这个漏洞, 最终的损失会更小&lt;/p&gt;

&lt;h3 id=&#34;3-业务更高效&#34;&gt;3. 业务更高效&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;团队要和更多人交流, 必须水平要高, 逼迫团队不断提高技术水平&lt;/li&gt;
&lt;li&gt;团队水平提高, 完成同样工作的时间缩短, 出错概率降低, 质量反而提高&lt;/li&gt;
&lt;li&gt;团队更快乐, 共有技术氛围, 团队更稳定&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何开源起来&#34;&gt;如何开源起来&lt;/h2&gt;

&lt;h3 id=&#34;尽量的开源纯技术方面的代码&#34;&gt;尽量的开源纯技术方面的代码&lt;/h3&gt;

&lt;p&gt;将业务无关的代码整理成清晰的模块和项目, 写好必要的说明文档, 放到 GitHub 上&lt;/p&gt;

&lt;h3 id=&#34;为使用的开源代码贡献代码&#34;&gt;为使用的开源代码贡献代码&lt;/h3&gt;

&lt;p&gt;如果使用的开源代码缺少自己需要的功能, 或者使用过程中发现 Bug 存在, 将功能代码添加进去, 或者修改 bug, 发 PR 给代码 owner&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小书包系统架构演进</title>
      <link>http://ssor.github.io/post/architechure_design_dyxsb/</link>
      <pubDate>Sun, 05 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/architechure_design_dyxsb/</guid>
      <description>&lt;p&gt;介绍小书包的架构历史及发展方向&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;系统组成&#34;&gt;系统组成&lt;/h2&gt;

&lt;p&gt;小书包整个系统的组成包含三部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;后台服务&lt;/li&gt;
&lt;li&gt;后台管理系统,&lt;/li&gt;
&lt;li&gt;终端应用( IOS 和 安卓)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写下第一行代码的时候, 也是小书包背负最多紧急任务的时候. 在这之前已经开发了一个版本,  对新版本的要求是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;克隆全部第一个版本所具有的功能(即使是错的)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在之前功能的基础上, 开发更高级的功能&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是面对需求, 这个版本没有办法完成任务:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;之前的版本基于 Java 技术栈, 现在的研发没有这方面的经验, 而且剩余的时间也不够转型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之前的代码在交接时缺少关键部分, 没法运行, 因某种原因不能与之前开发团队沟通&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经过评估, 在原来代码的基础上进行修补和改进, 成本比重新开发还要高&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;决定重新开发后, 选择了 Go 作为后台主要开发语言, 原因如&lt;a href=&#34;http://ssor.github.io/post/why_use_golang_for_backend/&#34;&gt;这篇文章&lt;/a&gt;所说, 另外还有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我自己对Go 开发有很长时间的经验, 遇到问题能够自行解决&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;语言简单, 有经验的程序员上手非常快&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Go 的运行效率也够高&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;主服务&#34;&gt;主服务&lt;/h2&gt;

&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;

&lt;p&gt;确定采用的技术后, 面临的需求如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开发要快, 但是功能模型还要超越之前的版本, 只有大约三个月的时间&lt;/li&gt;
&lt;li&gt;系统效率要足够, 可能有几十万人同时在线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了满足这两个需求, 系统第一版采用了内存模型, 在开发速度和性能的要求都达到了需求, 系统如期上线.&lt;/p&gt;

&lt;h3 id=&#34;动静分离&#34;&gt;动静分离&lt;/h3&gt;

&lt;p&gt;之前版本将所有的请求揽于一身, 包括静态资源的处理, 这部分消耗了系统很多的资源, 可以由成熟的方案做专门的优化处理.&lt;/p&gt;

&lt;h4 id=&#34;1-web静态资源文件&#34;&gt;1. Web静态资源文件&lt;/h4&gt;

&lt;p&gt;静态文件分离的第一步就是将Web所需的静态资源简单的分离出来, 以方便对静态文件的请求进行单独处理.&lt;/p&gt;

&lt;p&gt;通过将静态文件存放在单独的服务器上, 并通过 nginx 作为文件服务器后, 完成了初步的改造, 这样做的目的有两个:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网页静态资源请求不再有主服务处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对静态文件服务进行了测试, 为接下来的系统静态数据分离做出可行性测试&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;2-静态数据文件&#34;&gt;2. 静态数据文件&lt;/h4&gt;

&lt;p&gt;系统运行本身也会产生很多的静态文件数据,  数据量增大后, 也会极大影响系统资源的分配. 这些服务相对来说复杂了许多, 无法通过简单的文件拆分完成.&lt;/p&gt;

&lt;p&gt;举例来说, 系统对图书的服务包含了三个方面:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上传图书文件&lt;/li&gt;
&lt;li&gt;对上传的图书文件进行处理, 例如加密和修改部分文件&lt;/li&gt;
&lt;li&gt;向终端提供下载图书文件服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前三个方面的服务全部由系统本身处理, 流程相对简单. 为了将图书文件作为静态文件单独处理, 新的流程将上传图书的流程分为两步:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将图书文件本身上传到静态文件服务器, 并进行相应的逻辑处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将上传成功的标记作为参数提交到系统主服务, 主服务只负责数据处理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了完成第一个流程, 需要创建新的上传服务, 该服务接收文件的上传, 将文件处理后交由文件服务器提供文件下载服务, 并返回文件路径信息.&lt;/p&gt;

&lt;p&gt;文件信息之后会被提交到主服务, 并由主服务分发给终端 App, 终端 App 最终能够获取到最新正确的文件地址, 从而整个服务流程完成.&lt;/p&gt;

&lt;p&gt;完成了图书文件的上传流程的改造后, 将用到的上传服务进行简单的扩展, 就可以将包括图书封面, 文章阅读等最终以静态文件存在的流程全部进行改造, 包括在线聊天(后面会专门讲到)这个对文件上传需求量最高的系统服务, 这样的结果就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;系统主服务的负担进一步减轻&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似服务统一处理, 专门优化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用上传服务的新功能的开发复杂度降低&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;系统模块化&#34;&gt;系统模块化&lt;/h3&gt;

&lt;p&gt;尽管静态文件相关的服务被剥离出来, 但是系统主服务还是太过庞大, 造成的影响包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有功能模块的集中, 导致开发修改任何功能都是对主服务的改动, 任何的微小 bug 都会导致主服务受影响&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于新成员, 无论开发功能还是修改 bug, 设计的代码范围大, 掌握系统设计的速度也比较慢&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于所有的资源都在同一个区域内, 功能开发很容易形成依赖, 如果开发成员的模块化意识差, 很容易写出混乱的代码, 给维护带来较大麻烦&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这些问题, 需要逐渐的将主服务中的功能进行拆分, 最终形成独立的功能服务.&lt;/p&gt;

&lt;h3 id=&#34;大前后端的分离&#34;&gt;大前后端的分离&lt;/h3&gt;

&lt;p&gt;一直以来, 后台管理系统与后台的数据服务是集合在主服务中的, 这样导致的问题就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;即使业务需求导致的页面变化非常微小, 也需要对主服务进行升级&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前端开发需要搭建和主服务同样的系统才能进行开发, 增大了开发难度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这两个问题, 对系统主服务中的前端部分拆分成单独的前端系统, 通过 API 的方式调用数据&lt;/p&gt;

&lt;h3 id=&#34;功能模块的拆分&#34;&gt;功能模块的拆分&lt;/h3&gt;

&lt;p&gt;功能服务独立化时面对的问题主要是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何确定功能的边界&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之前同一个服务进程内的依赖问题如何解决&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模块之间的数据如何同步&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-功能边界的确定&#34;&gt;1.功能边界的确定&lt;/h4&gt;

&lt;p&gt;这个需要从两个方面考虑:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总结出业务特点, 渐渐划清了模块的大体边界&lt;/li&gt;
&lt;li&gt;根据业务的变化及时调整&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-服务的数据依赖与同步&#34;&gt;2.服务的数据依赖与同步&lt;/h4&gt;

&lt;p&gt;将原来服务切分进行拆分, 之前简单的在内存中查找数据就可以完成的操作, 现在划分为多个流程的组合, 很多问题就会产生, 比如说中间出错怎么处理, 性能降低较大.&lt;/p&gt;

&lt;p&gt;直觉的处理方案就是技术替代. 这方面有很多技术上的解决方案, 比如 内部 Restful API, RPC 等等, 用这些技术手段替代之前的内存查找, 最起码从表面上完成了拆分.&lt;/p&gt;

&lt;p&gt;但是, 如果解决只是这个思路进行拆分, 我觉得有很大的浪费. 因为模块的划分, 本来就是从底层逼迫架构设计者考虑之前数据调用的合理性. 如果能够通过模块的划分, 将原来隐藏的问题暴露出来, 通过重新思考, 架构方案的改进从而对整个系统加以改进, 那对于系统的清晰和可维护性一定是个巨大的进步.&lt;/p&gt;

&lt;p&gt;对于模块独立后, 对于必须依赖的数据的同步, 我们采用的方案是中间件事件提醒, 然后从数据库查询同步的方案. 具体来说, 每一个模块都有自己的缓存数据, 每个模块都可能具有读和写的操作, 如果发生写操作, 那么在数据成功写入到数据库完成持久化以后, 需要发送一个对该数据发生变化的事件提醒到中间件, 依赖该数据的模块通过订阅该事件获得提醒, 之后通过查询数据库中的相关数据, 更新缓存数据.&lt;/p&gt;

&lt;h4 id=&#34;3-成果&#34;&gt;3.成果&lt;/h4&gt;

&lt;p&gt;系统模块化之后, 不仅解决了之前存在的问题, 还额外得到了另外一些好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于模块之间的数据依赖, 促使系统不断的向无状态, 内聚的方向进化, 系统之间的耦合性降低, 整个系统更加清晰, 为之后功能的开发提供了坚实的基础&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于每个模块负责管理自己的数据, 但整个系统对外提供的 API 需要提供跨模块的数据, 促使缓存层的单独设计, 同时将终端和后台的 API 进行了分类处理&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;系统的无缝升级&#34;&gt;系统的无缝升级&lt;/h3&gt;

&lt;p&gt;好长时间以来, 系统的升级维护工作都需要暂停服务, 暂停服务从公司业务管理制度上需要经历一系列的流程, 流程的繁杂会阻碍功能的及时升级, 这样会造成很多问题:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能不能快速上线, 会造成功能的堆积, 堆积增多与升级出错的概率成正比, 导致系统升级出现意外的可能性增大&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;功能不能及时上线, 功能的反馈及时性降低, 不能及时跟进客户真正需求, 时间成本增大&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;功能不能上线, 依据该功能的后续开发工作不确定性增大, 开发成本升高&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;体验差&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;造成这个问题的主要原因在于系统的缓存使用的是内存, 功能升级需要重新加载数据, 而多个实例内存级别实时数据同步的成本较高.&lt;/p&gt;

&lt;p&gt;为了解决这个问题, 系统模块中的缓存逐渐用 redis 替代, 通过将缓存与功能分离, 可以同时启动同一模块的多个实例, 通过负载均衡的配置, 可以逐步用升级版本的实例代替就实例, 实现无缝升级.&lt;/p&gt;

&lt;p&gt;另外一个好处就是, 再将模块缓存与功能分离后, 顺带实现了系统的横向扩展, 系统的承载量不再是问题&lt;/p&gt;

&lt;h3 id=&#34;向数据平台的演进&#34;&gt;向数据平台的演进&lt;/h3&gt;

&lt;p&gt;经过之前的改进, 整个系统在业务上基本不存在大的问题. 随着系统的增大, 和第三方资源的对接成为主要考虑的方向, 不仅包括接入第三方的数据资源, 也包括开发资源, 如何向第三方开放数据接口, 增大系统的功能扩展能力摆在面前.&lt;/p&gt;

&lt;p&gt;解决思路是整个系统向平台化演进. 将内部的各个模块在现有的业务层和数据层的基础上, 从纵向上进一步细化拆分, 业务层分为基础业务和组合业务, 数据层分为业务数据和基础数据, 每个层次上开放合适的 API服务, 第三方的开发能力在服务基础上, 就可以快速得以实现.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>怎样才能写出绝对的代码</title>
      <link>http://ssor.github.io/post/make_code_most_beautiful/</link>
      <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/make_code_most_beautiful/</guid>
      <description>&lt;p&gt;怎样写出无可指摘的代码
&lt;/p&gt;

&lt;h2 id=&#34;什么是绝对的代码&#34;&gt;什么是绝对的代码&lt;/h2&gt;

&lt;p&gt;任何人见到这套代码, 都不会说这个架构设计的不好, 这个代码还可以再优化一下. 最多可以说用另外一套架构可以完成同样的功能, 可以有另外的优点, 但是代价是牺牲当前这套架构的一些优点, 换句话说, 当前的代码实现了指定的功能, 具有某些优点, 已经没法子再改进, 一改进就是另外一套东西了&lt;/p&gt;

&lt;h2 id=&#34;具体方法&#34;&gt;具体方法&lt;/h2&gt;

&lt;h3 id=&#34;1-目标清晰具体&#34;&gt;1. 目标清晰具体&lt;/h3&gt;

&lt;p&gt;目标清晰的意义在于划定功能的边界, 边界确定的清晰, 功能代码就越清晰. 如果目标模棱两可, 那后人维护的时候就会以为某个功能做得不够全面, 而实际上是对功能的理解偏差&lt;/p&gt;

&lt;h3 id=&#34;2-思路简单到极致&#34;&gt;2. 思路简单到极致&lt;/h3&gt;

&lt;p&gt;没有人可以通过将功能变得复杂而使得代码让人无可指摘, 总可以通过添加一些代码实现新的功能. 只有在精简到极致的情况下, 才有可能让人无可再减, 也就无可指摘&lt;/p&gt;

&lt;h3 id=&#34;3-架构清晰&#34;&gt;3. 架构清晰&lt;/h3&gt;

&lt;p&gt;架构清晰的意义在于表现思路的简单. 模块组合简单合理, 没有冗余的模块, , 功能实现层次分明, 具有必须的模块和层次, 没有多余的层次抽象, 每个人都能看得懂, 最简单的做法就是按照当前的思路去实现.&lt;/p&gt;

&lt;h3 id=&#34;4-清晰的函数&#34;&gt;4. 清晰的函数&lt;/h3&gt;

&lt;p&gt;每个函数都是独立的, 每个函数的命名都很清晰, 每个函数的功能都很具体, 函数这些构成系统的细胞都很简单明确, 然后优美的组合成模块, 保证了系统底层的简单干净&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mongo 数据库的合理使用</title>
      <link>http://ssor.github.io/post/rebuild_a_mongo_pool/</link>
      <pubDate>Sat, 11 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/rebuild_a_mongo_pool/</guid>
      <description>&lt;p&gt;如何防止 Mongo 数据库因为连接数过高导致异常
&lt;/p&gt;

&lt;h1 id=&#34;思路&#34;&gt;思路&lt;/h1&gt;

&lt;p&gt;防止 Mongo 连接数过高需要解决两个问题:
1. 如何限制应用使用的连接数
2. 应用如何合理使用有限的连接&lt;/p&gt;

&lt;p&gt;对于第一个问题, 现在的处理方案是使用连接池, 在连接池内设定最高数量的连接, 重复利用而不随意增多, 从而从整体上保证了连接的数量&lt;/p&gt;

&lt;p&gt;但是, 如果之前的应用中使用连接的方式根本没有考虑连接资源有限的话, 改造起来相对麻烦一些. 很多的应用对连接数使用数量来源于业务访问量, 新增一个访问量, 则简单的新创建一个连接, 等于将业务的访问压力转嫁到数据库上, 为系统的稳定埋下了隐患. 因此, 对于应用内使用有限连接的方式, 从两个角度解决:
1. 强制使用有限连接, 如果因为连接数暂时不够导致业务无法及时处理, 将业务推迟, 由业务发起方重新请求
2. 对于无法推迟的业务处理, 将请求缓存, 使用有限连接排队处理请求&lt;/p&gt;

&lt;h1 id=&#34;基本连接池&#34;&gt;基本连接池&lt;/h1&gt;

&lt;h2 id=&#34;连接池的好处&#34;&gt;连接池的好处&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;连接 Mongo 时, 如果连接太多, 会导致数据库因并发连接太多而崩溃;&lt;/li&gt;
&lt;li&gt;如果 Mongo 采用了 Primary 和 Secondary 模式, 会导致各个实例的角色不断转换, 从而导致数据不停的在各个实例之间同步, 不仅造成了服务器的负担, 而且导致数据库出错的概率急剧增大, 甚至导致整个系统的运行出错.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这个问题, 就要限制各个应用连接 Mongo 的连接数量, 应用于&lt;a href=&#34;https://github.com/ssor/mongopool&#34;&gt;生产环境的库&lt;/a&gt;, 基于 Go 开发&lt;/p&gt;

&lt;h2 id=&#34;支持特性&#34;&gt;支持特性&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;限制了应用并发连接数量&lt;/li&gt;
&lt;li&gt;数据库断线自动重连&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何查看连接数量&#34;&gt;如何查看连接数量&lt;/h2&gt;

&lt;p&gt;linux :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo netstat -apn | grep 27107
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;macOS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lsof -nP -iTCP  | grep mongo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;连接池原理&#34;&gt;连接池原理&lt;/h2&gt;

&lt;h3 id=&#34;数量限制&#34;&gt;数量限制&lt;/h3&gt;

&lt;p&gt;每次需要创建连接时, 首先申请一个连接, 如果已经超过了一定数量, 则请求被驳回, 也就是不能创建新连接, 从而达到了限制连接数量的目的&lt;/p&gt;

&lt;h3 id=&#34;数据库断线重连&#34;&gt;数据库断线重连&lt;/h3&gt;

&lt;p&gt;数据库需要重启时, 不需要要重新启动应用.&lt;/p&gt;

&lt;p&gt;当操作数据库失败时, 启动之前创建的连接的刷新流程&lt;/p&gt;

&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;参照该库提供的&lt;a href=&#34;https://github.com/ssor/mongopool/blob/master/example/main.go&#34;&gt;例子&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;支持事务的连接池&#34;&gt;支持事务的连接池&lt;/h1&gt;

&lt;p&gt;Mongo 本身不支持事务, 但是通过利用 Mongo 本身的一些特性, 可以使其支持简单的事务处理. 这是一个&lt;a href=&#34;https://github.com/ssor/mongo_pool_txn&#34;&gt;应用于生产环境的库&lt;/a&gt;, 敬请参考&lt;/p&gt;

&lt;h1 id=&#34;额外的开源计划&#34;&gt;额外的开源计划&lt;/h1&gt;

&lt;p&gt;对于具体如何解决之上, 之后会考虑开源一个实用的实例, 敬请期待&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Consul在服务发现中的应用</title>
      <link>http://ssor.github.io/post/how_to_use_consul/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/how_to_use_consul/</guid>
      <description>&lt;p&gt;Consul的基本原理及其在服务发现中的使用&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;服务发现&#34;&gt;服务发现&lt;/h2&gt;

&lt;p&gt;服务发现,通俗的讲,就是通过关键字查询特定的服务.&lt;/p&gt;

&lt;h2 id=&#34;服务发现的意义&#34;&gt;服务发现的意义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果服务本身发生了变化, 只需要更新服务即可, 与服务相关的关键字不变, 因此服务的使用者不需要关心该变化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务进行升级后, 如果服务要求的参数不变(平滑升级可以做到), 服务使用者只需要用新的关键字替换之前的关键字即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同一个服务的多个版本可以同时存在, 使用者可以根据需求方便的切换版本&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;consul-是什么&#34;&gt;Consul 是什么&lt;/h2&gt;

&lt;p&gt;Consul是 &lt;a href=&#34;https://www.hashicorp.com/&#34;&gt;HashiCorp&lt;/a&gt;开发的用于服务发现的系统. 它的主要特性有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持通过 DNS 和 HTTP 发现服务&lt;/li&gt;
&lt;li&gt;提供服务的健康检查&lt;/li&gt;
&lt;li&gt;键值存储&lt;/li&gt;
&lt;li&gt;多数据中心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过服务发现的方式为使用者提供服务, 稳定是最重要的考虑因素, Consul 的去中心化的多节点提供稳定的服务. 同时因为健康检查的存在, 可以保证服务的有效性.&lt;/p&gt;

&lt;h2 id=&#34;consul-的部署&#34;&gt;Consul 的部署&lt;/h2&gt;

&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;

&lt;p&gt;每台服务器上至少有一个 Consul 的节点( Agent ), 节点有两种模式: 服务器模式和客户端模式.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器模式提供服务注册和查找等功能, 是 Consul 去中心化的关键节点,推荐至少部署三个节点.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端模式负责转发服务请求到服务器模式的节点.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于两种模式的节点负责功能的不同, 可以假设客户端模式的节点是稳定存在的, 而服务器模式的节点可能会异常退出.&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;根据系统&lt;a href=&#34;https://www.consul.io/downloads.html&#34;&gt;下载&lt;/a&gt;合适的版本, 并解压至合适的目录.&lt;/p&gt;

&lt;p&gt;假设有4台服务器, IP分别为 &lt;strong&gt;172.16.1.34&lt;/strong&gt;, &lt;strong&gt;172.16.1.35&lt;/strong&gt;, &lt;strong&gt;172.16.1.37&lt;/strong&gt;, &lt;strong&gt;172.16.1.69&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将在 34, 35, 69 上启动服务器模式节点, 在37上启动客户端模式节点, 启动命令如下:&lt;/p&gt;

&lt;h5 id=&#34;34&#34;&gt;34&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;./consul agent -server -bootstrap-expect=3 -node=agent34 -data-dir=./ &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;35&#34;&gt;35&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt; ./consul agent -server -bootstrap-expect=3 -node=agent35 -data-dir=./ &amp;amp;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;69&#34;&gt;69&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt; ./consul agent -server -bootstrap-expect=3 -node=agent69 -data-dir=./ &amp;amp;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;37&#34;&gt;37&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt; ./consul agent  -node=agent37 -retry-join=172.16.1.35 -data-dir=./ &amp;amp; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在35和34服务器上运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ./consul join 172.16.1.69 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三个服务器模式节点将选出一个 leader, 服务启动完成.&lt;/p&gt;

&lt;p&gt;查看一下节点状态, 运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ./consul members 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果类似如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node     Address           Status  Type    Build  Protocol  DC
agent34  172.16.1.34:8301  alive   server  0.7.2  2         dc1
agent35  172.16.1.35:8301  alive   server  0.7.2  2         dc1
agent37  172.16.1.37:8301  alive   client  0.7.2  2         dc1
agent69  172.16.1.69:8301  alive   server  0.7.2  2         dc1

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;h5 id=&#34;使用http-api&#34;&gt;使用HTTP API&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注册服务 &lt;a href=&#34;https://www.consul.io/docs/agent/http/agent.html#agent_service_register&#34;&gt;/v1/agent/service/register&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找服务 &lt;a href=&#34;https://www.consul.io/docs/agent/http/health.html#health_service&#34;&gt;/v1/health/service/&lt;service&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;使用-sdk&#34;&gt;使用 SDK&lt;/h5&gt;

&lt;p&gt;系统中使用 Consul 需要对其 HTTP API 进行封装, 因此可以直接使用官方封装的 Go 版的 SDK&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注册服务 参考&lt;a href=&#34;https://github.com/ssor/consul_service_reg/blob/master/main.go&#34;&gt;代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找服务 参考&lt;a href=&#34;https://github.com/ssor/consul_query_service_example/blob/master/main.go&#34;&gt;代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;基本的使用方法介绍完毕, 下一步将对实际工程中的使用问题进行补充&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小书包在线聊天系统架构演进</title>
      <link>http://ssor.github.io/post/architechure_desigin_of_chat/</link>
      <pubDate>Wed, 05 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/architechure_desigin_of_chat/</guid>
      <description>&lt;p&gt;介绍小书包聊天系统的架构历史及发展方向&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;技术方案&#34;&gt;技术方案&lt;/h2&gt;

&lt;p&gt;开发在线聊天功能考虑的第一个问题是: 能不能用第三方的系统?&lt;/p&gt;

&lt;p&gt;第三方的系统已经有成熟的商业解决方案, 自行开发成本很高. 但问题在于:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果经过第三方系统, 数据安全方面能不能得到保证&lt;/li&gt;
&lt;li&gt;如果要对聊天内容进行限制, 第三方系统是否能够做到&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过调研, 发现上面两个问题基本很难解决.&lt;/p&gt;

&lt;p&gt;那么能不能用开源的系统? 有许多具有很多应用案例的组合可以选择. 但是经过研究发现, 这些系统在部署和维护上也需要较大的投入, 再结合我们的技术选型和初期的产品需求, 发现自己开发一个反而成本较低, 而且后期也可以按照业务需求灵活改动.&lt;/p&gt;

&lt;h3 id=&#34;单例&#34;&gt;单例&lt;/h3&gt;

&lt;p&gt;初期的产品需求比较简单, 只要登录的人能够在群内互相发送消息即可, 不需要群的管理和消息的持久化&lt;/p&gt;

&lt;p&gt;所以第一版的在线聊天经过几天的开发就可以使用了. 它的功能包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户上线时, 访问服务, 服务根据用户属性, 将其分配到预设的群中&lt;/li&gt;
&lt;li&gt;用户发送消息, 该消息会通过 websocket 转发给群内的其他成员&lt;/li&gt;
&lt;li&gt;支持文字, 图片和语音&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一版在一台服务器上满足了十万人左右的聊天需求&lt;/p&gt;

&lt;h3 id=&#34;多节点&#34;&gt;多节点&lt;/h3&gt;

&lt;p&gt;用户量的增多对系统提出了更多的挑战, 主要有以下几个:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户量增大, 单个服务器难以承载&lt;/li&gt;
&lt;li&gt;登录过程较慢, 系统升级造成服务的中断&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这些问题, 系统在架构上进行以下的改进:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;预先创建群&lt;/li&gt;
&lt;li&gt;分配服务器节点和聊天功能进行模块上的分离, 分别由不同的服务负责, 各个模块可以单独部署&lt;/li&gt;
&lt;li&gt;用户登录采用两段式, 即先获取分配服务器节点, 通过分配服务器获取登录节点, 最终在分配的登录服务器节点上登录&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;改造完成后, 用户量承载方面已经没有问题, 由于多节点的支持, 用户登录也较为快速, 基本解决问题&lt;/p&gt;

&lt;h3 id=&#34;高可用&#34;&gt;高可用&lt;/h3&gt;

&lt;p&gt;随着用户分布范围的扩大, 遇到的网络情况变得复杂起来; 同时对服务的可用性也提出了更高的要求. 这种情况下需要解决的问题有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器分配节点的服务器失效&lt;/li&gt;
&lt;li&gt;终端对外网络有限制, 无法连接到服务器&lt;/li&gt;
&lt;li&gt;用户分配的节点服务器失效或者系统升级重启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决上述问题, 系统进行了如下改进:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端路由和分配服务器多点
&amp;gt; 客户端进行第一段的登录请求时, 获取的将会是一组分配服务器地址, 客户端轮询服务器列表, 其中一个失效不会阻碍登录的进行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户群在各个聊天节点的自动迁移, 解决了节点升级和失效的问题&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;未来计划&#34;&gt;未来计划&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用户消息的持久化&lt;/li&gt;
&lt;li&gt;用户群在节点间迁移, 消息自动同步&lt;/li&gt;
&lt;li&gt;跳出聊天的范畴, 成为一个数据传输管道&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>后台开发选择了 Go 语言</title>
      <link>http://ssor.github.io/post/why_use_golang_for_backend/</link>
      <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/why_use_golang_for_backend/</guid>
      <description>&lt;p&gt;经过认真思考, 还是选择了 Go 作为主力开发语言
&lt;/p&gt;

&lt;p&gt;后台开发语言的可选项很多, 最没有错误的选择是 Java, 还有 JVM 平台的其它言语 Scala, closure也有大牛在用, 尽管如此, 这些语言各自存在着不同的问题. 与此同时, 也有很多的新语言不断涌现, 试图解决之前语言在开发中遇到的问题. 新语言的问题在于尚未经过时间的检验, 对于产品的开发可能存在风险, 因此需要在风险和新语言的特性之前做出权衡. 我们遇到的是 Go 语言与其它语言.&lt;/p&gt;

&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;

&lt;h3 id=&#34;开源&#34;&gt;开源&lt;/h3&gt;

&lt;p&gt;一定要选择开源的编程语言. 不是因为可以自己往语言里加自己想要的特性, 而是因为, 无论在什么情况下, 不会突然发生语言无人维护的情况; 如果官方放弃该语言, 在确实需要的情况下, 可以自行维护, 保证对已开发系统的支持.&lt;/p&gt;

&lt;h3 id=&#34;设计简单&#34;&gt;设计简单&lt;/h3&gt;

&lt;p&gt;代码直观, 没有各种类的理论的设定, 没有各种看起来很有效率的特性, 代码阅读更流畅, 很难产生误解, 易于维护.&lt;/p&gt;

&lt;h3 id=&#34;快速的静态编译&#34;&gt;快速的静态编译&lt;/h3&gt;

&lt;p&gt;在构建复杂的后端系统时, 在当前阶段, 静态编译在消除隐藏问题方面有着很大的优势, 可以减少大量的测试, 保证系统稳定的同时, 极大的提高开发效率.&lt;/p&gt;

&lt;h3 id=&#34;跨平台编译&#34;&gt;跨平台编译&lt;/h3&gt;

&lt;p&gt;系统的部署一直是个很大的问题, 世界上最好的语言 PHP 之所以最好有一部分原因是跨平台, 在 windows 下开发完成后, 直接部署在 linux 服务器上, 表现基本一致. 相比来说, Go 在这方面的优势只大不小. 在 macOS 上开发完成后, 可以直接编译为 linux 上运行的二进制包, 跨平台表现的一致性更强. 同样的系统不需要任何修改就可以跨平台运行, 极大的降低了开发成本.&lt;/p&gt;

&lt;h3 id=&#34;健壮全面的标准库&#34;&gt;健壮全面的标准库&lt;/h3&gt;

&lt;p&gt;Go 的发布同时带来了健壮齐全的标准库, 一般的系统都不需要额外的外部库依赖, 对生态发展的依赖性极低. 标准库的维护和升级兼容性工作由设计者维护, 保证了系统升级时的稳定可靠.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>