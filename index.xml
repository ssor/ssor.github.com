<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>我思故我在</title>
    <link>http://ssor.github.io/index.xml</link>
    <description>Recent content on 我思故我在</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Apr 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://ssor.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>早睡早起与人生发展</title>
      <link>http://ssor.github.io/post/sleep_and_wakeup_early_is_a_life_style/</link>
      <pubDate>Wed, 05 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/sleep_and_wakeup_early_is_a_life_style/</guid>
      <description>&lt;p&gt;早睡早起的人生 style
&lt;/p&gt;

&lt;p&gt;最近养成了早睡早起的习惯, 晚上十点左右睡, 早晨六点起床, 精神抖擞. 吃早饭, 挤地铁上班, 到公司八点半左右.&lt;/p&gt;

&lt;p&gt;经历了一段时间发现了许多好处&lt;/p&gt;

&lt;h2 id=&#34;思考与写作&#34;&gt;思考与写作&lt;/h2&gt;

&lt;p&gt;公司打卡九点半,  我基本第一个到公司, 所以我有很长安安静静的一个人的时间, 可以对一些疑难问题进行比较深入的思考, 这是除了走路状态和入睡前状态的思考之外, 最能蹦出灵感的状态. 至少一半的博客是在这个时间段完成的.&lt;/p&gt;

&lt;p&gt;博客促进了思考, 记录了自己的发展, 显著的提高了沟通能力, 早睡早起的习惯功不可没&lt;/p&gt;

&lt;h2 id=&#34;职业发展&#34;&gt;职业发展&lt;/h2&gt;

&lt;p&gt;早起要求尽量早睡(我不是一天只睡三四个小时的怪物), 要求我的工作性质尽量没有较晚的应酬, 那就意味着不可能把和大量的人搞好关系作为第一要务, 那我只能靠技术和能力吃饭, 那我应该多思考多学习不断进步. 对于我自己, 研究各种技术本来就是我的兴趣所在, 兴趣和工作两全其美, 人生如此无憾矣.&lt;/p&gt;

&lt;h2 id=&#34;家庭和美&#34;&gt;家庭和美&lt;/h2&gt;

&lt;p&gt;工作的时间都安排在白天, 很少有突发的事情, 那晚上的时间就可以多个家人沟通交流. 和老婆讨论一下互相工作上的烦恼与进步, 评论一下最新的电影, 看着孩子一点点的不断 get 新技能,  顿时有种心灵上的清新&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>提倡公司开源运动</title>
      <link>http://ssor.github.io/post/the_open_source_for_company/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/the_open_source_for_company/</guid>
      <description>&lt;p&gt;为什么要在公司技术管理上提倡开源, 如何开源
&lt;/p&gt;

&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;

&lt;p&gt;保证技术公司拥有强劲竞争力的方法是拥有一支高水平的技术团队.  打造这样高水平的团队有几个方法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;高水平的招聘&lt;/li&gt;
&lt;li&gt;自行培养&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个方法优点是直观简单,  但也有缺陷:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代价高昂&lt;/li&gt;
&lt;li&gt;很难招&lt;/li&gt;
&lt;li&gt;合作难&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;战略上来说第二种方法几乎没有第一种方法的缺点, 除了时间较长外, 显然更加最合适.&lt;/p&gt;

&lt;p&gt;那么应该如何培养呢? 这里有克服几个问题:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;什么是更好的技术人要客观, 不能几个人说了算, 评价标准必须客观&lt;/li&gt;
&lt;li&gt;不能敝帚自珍, 多接触圈内的高手才能意识到自己的不足和努力的方向, 才有可能提高自己的技术水平&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;怎么解决这些问题? 从外部请专家? 定期交流? 多参加技术交流大会? 这些方式不仅效率低, 效果也不是很好. 其实最好的方式就是开源.&lt;/p&gt;

&lt;h2 id=&#34;什么是开源&#34;&gt;什么是开源&lt;/h2&gt;

&lt;p&gt;开源不是简单的把自己的代码放到 GitHub 上, 让所有人都可以访问. 开源的目标是和所有人互动.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把自己的代码整理好, 包括代码和相关文档, 可以让其他人参与进项目本身&lt;/li&gt;
&lt;li&gt;参与别人的项目, 贡献自己的想法和代码&lt;/li&gt;
&lt;li&gt;多听取意见, 然后自己决定&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;开源的忧虑&#34;&gt;开源的忧虑&lt;/h2&gt;

&lt;p&gt;开源让很多公司的管理者产生很多忧虑:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果代码别人都知道了, 那竞争对手是不是就可以复制我, 然后和我竞争了?&lt;/li&gt;
&lt;li&gt;系统的漏洞是不是就暴露出来了? 这样会不会影响公司发展?&lt;/li&gt;
&lt;li&gt;团队搞开源, 放在业务上的精力变少了, 那公司还怎么发展?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;慢慢来解释这些问题.&lt;/p&gt;

&lt;h3 id=&#34;1-代码的开放&#34;&gt;1. 代码的开放&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;如果竞争对手只是把你的系统运转起来就能和你竞争, 那说明你的产品本身竞争力就不强&lt;/li&gt;
&lt;li&gt;即使没有你的代码, 人家一样和你竞争, 只要你的技术不是独一无二的, 就不存在什么大的门槛.&lt;/li&gt;
&lt;li&gt;让你时刻意识到公司的竞争力不在几行代码上, 而在产品和服务上, 认真做好产品和服务才是根本&lt;/li&gt;
&lt;li&gt;如果能吸引到公司外的人贡献代码, 那就等于有人免费为公司工作&lt;/li&gt;
&lt;li&gt;多个人多一条思路, 系统的功能和性能方面可能有意外的收获&lt;/li&gt;
&lt;li&gt;多人的参与, 正常情况下, 代码质量会更高&lt;/li&gt;
&lt;li&gt;如果有人离职了, 从代码贡献者里面直接找一个替代&lt;/li&gt;
&lt;li&gt;发现有人对部分代码特别感兴趣, 直接招聘他进公司&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2-为系统漏洞付出的代价更小&#34;&gt;2. 为系统漏洞付出的代价更小&lt;/h3&gt;

&lt;p&gt;如果系统本身存在漏洞, 黑客迟早会抓住这个机会. 如果能因为开放代码使得有人能提前提出这个漏洞, 最终的损失会更小&lt;/p&gt;

&lt;h3 id=&#34;3-业务更高效&#34;&gt;3. 业务更高效&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;团队要和更多人交流, 必须水平要高, 逼迫团队不断提高技术水平&lt;/li&gt;
&lt;li&gt;团队水平提高, 完成同样工作的时间缩短, 出错概率降低, 质量反而提高&lt;/li&gt;
&lt;li&gt;团队更快乐, 共有技术氛围, 团队更稳定&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何开源起来&#34;&gt;如何开源起来&lt;/h2&gt;

&lt;h3 id=&#34;尽量的开源纯技术方面的代码&#34;&gt;尽量的开源纯技术方面的代码&lt;/h3&gt;

&lt;p&gt;将业务无关的代码整理成清晰的模块和项目, 写好必要的说明文档, 放到 GitHub 上&lt;/p&gt;

&lt;h3 id=&#34;为使用的开源代码贡献代码&#34;&gt;为使用的开源代码贡献代码&lt;/h3&gt;

&lt;p&gt;如果使用的开源代码缺少自己需要的功能, 或者使用过程中发现 Bug 存在, 将功能代码添加进去, 或者修改 bug, 发 PR 给代码 owner&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>评定程序员等级的几个方面</title>
      <link>http://ssor.github.io/post/some_keypoint_of_a_good_programmer/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/some_keypoint_of_a_good_programmer/</guid>
      <description>&lt;p&gt;如何评定程序员的等级❓ 应该指导初级程序员向哪个方向努力❓ 就这两个问题提出自己的想法
&lt;/p&gt;

&lt;h2 id=&#34;出发点&#34;&gt;出发点&lt;/h2&gt;

&lt;p&gt;为了提高系统代码的可维护性和稳定性, 构成系统的代码必须有质量上的要求, 但是评价质量的指标各有各的优点, 仅拣选出部分认为关键的方面, 以供参考.&lt;/p&gt;

&lt;h2 id=&#34;升级指标&#34;&gt;升级指标&lt;/h2&gt;

&lt;h3 id=&#34;1-功能&#34;&gt;1. 功能&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;按照需求,  实现了既定功能&lt;/li&gt;
&lt;li&gt;设计简单的实现方法, 没有各种奇巧淫技&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;2-函数&#34;&gt;2. 函数&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;函数命名简单清晰&lt;/li&gt;
&lt;li&gt;函数名与内容匹配&lt;/li&gt;
&lt;li&gt;每个函数的行数尽量不超过40行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-单元测试&#34;&gt;3. 单元测试&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;每个函数理论上都可以进行单元测试&lt;/li&gt;
&lt;li&gt;系统的主要逻辑有单元测试覆盖&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;4-系统的模块化&#34;&gt;4. 系统的模块化&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;不同功能的代码文件放在不同的文件夹内&lt;/li&gt;
&lt;li&gt;系统设计上不同功能的代码内聚在不同的package内&lt;/li&gt;
&lt;li&gt;整个系统具有明显的抽象层次&lt;/li&gt;
&lt;li&gt;层次间的关系简单合理&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;5-文档的撰写&#34;&gt;5. 文档的撰写&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;文档说明清晰易懂&lt;/li&gt;
&lt;li&gt;图文并茂&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;评定方法&#34;&gt;评定方法&lt;/h2&gt;

&lt;p&gt;向尽量多的人展现自己的作品&lt;/p&gt;

&lt;h2 id=&#34;提高的方法&#34;&gt;提高的方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多学多练,&lt;/li&gt;
&lt;li&gt;多看优秀的代码&lt;/li&gt;
&lt;li&gt;多与高水平的人一起写代码&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>小书包系统架构演进</title>
      <link>http://ssor.github.io/post/architechure_design_dyxsb/</link>
      <pubDate>Sun, 05 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/architechure_design_dyxsb/</guid>
      <description>&lt;p&gt;介绍小书包的架构历史及发展方向&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;系统组成&#34;&gt;系统组成&lt;/h2&gt;

&lt;p&gt;小书包整个系统的组成包含三部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;后台服务&lt;/li&gt;
&lt;li&gt;后台管理系统,&lt;/li&gt;
&lt;li&gt;终端应用( IOS 和 安卓)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写下第一行代码的时候, 也是小书包背负最多紧急任务的时候. 在这之前已经开发了一个版本,  对新版本的要求是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;克隆全部第一个版本所具有的功能(即使是错的)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在之前功能的基础上, 开发更高级的功能&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是面对需求, 这个版本没有办法完成任务:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;之前的版本基于 Java 技术栈, 现在的研发没有这方面的经验, 而且剩余的时间也不够转型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之前的代码在交接时缺少关键部分, 没法运行, 因某种原因不能与之前开发团队沟通&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经过评估, 在原来代码的基础上进行修补和改进, 成本比重新开发还要高&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;决定重新开发后, 选择了 Go 作为后台主要开发语言, 原因如&lt;a href=&#34;http://ssor.github.io/post/why_use_golang_for_backend/&#34;&gt;这篇文章&lt;/a&gt;所说, 另外还有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我自己对Go 开发有很长时间的经验, 遇到问题能够自行解决&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;语言简单, 有经验的程序员上手非常快&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Go 的运行效率也够高&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;主服务&#34;&gt;主服务&lt;/h2&gt;

&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;

&lt;p&gt;确定采用的技术后, 面临的需求如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开发要快, 但是功能模型还要超越之前的版本, 只有大约三个月的时间&lt;/li&gt;
&lt;li&gt;系统效率要足够, 可能有几十万人同时在线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了满足这两个需求, 系统第一版采用了内存模型, 在开发速度和性能的要求都达到了需求, 系统如期上线.&lt;/p&gt;

&lt;h3 id=&#34;动静分离&#34;&gt;动静分离&lt;/h3&gt;

&lt;p&gt;之前版本将所有的请求揽于一身, 包括静态资源的处理, 这部分消耗了系统很多的资源, 可以由成熟的方案做专门的优化处理.&lt;/p&gt;

&lt;h4 id=&#34;1-web静态资源文件&#34;&gt;1. Web静态资源文件&lt;/h4&gt;

&lt;p&gt;静态文件分离的第一步就是将Web所需的静态资源简单的分离出来, 以方便对静态文件的请求进行单独处理.&lt;/p&gt;

&lt;p&gt;通过将静态文件存放在单独的服务器上, 并通过 nginx 作为文件服务器后, 完成了初步的改造, 这样做的目的有两个:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网页静态资源请求不再有主服务处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对静态文件服务进行了测试, 为接下来的系统静态数据分离做出可行性测试&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;2-静态数据文件&#34;&gt;2. 静态数据文件&lt;/h4&gt;

&lt;p&gt;系统运行本身也会产生很多的静态文件数据,  数据量增大后, 也会极大影响系统资源的分配. 这些服务相对来说复杂了许多, 无法通过简单的文件拆分完成.&lt;/p&gt;

&lt;p&gt;举例来说, 系统对图书的服务包含了三个方面:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上传图书文件&lt;/li&gt;
&lt;li&gt;对上传的图书文件进行处理, 例如加密和修改部分文件&lt;/li&gt;
&lt;li&gt;向终端提供下载图书文件服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前三个方面的服务全部由系统本身处理, 流程相对简单. 为了将图书文件作为静态文件单独处理, 新的流程将上传图书的流程分为两步:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将图书文件本身上传到静态文件服务器, 并进行相应的逻辑处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将上传成功的标记作为参数提交到系统主服务, 主服务只负责数据处理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了完成第一个流程, 需要创建新的上传服务, 该服务接收文件的上传, 将文件处理后交由文件服务器提供文件下载服务, 并返回文件路径信息.&lt;/p&gt;

&lt;p&gt;文件信息之后会被提交到主服务, 并由主服务分发给终端 App, 终端 App 最终能够获取到最新正确的文件地址, 从而整个服务流程完成.&lt;/p&gt;

&lt;p&gt;完成了图书文件的上传流程的改造后, 将用到的上传服务进行简单的扩展, 就可以将包括图书封面, 文章阅读等最终以静态文件存在的流程全部进行改造, 包括在线聊天(后面会专门讲到)这个对文件上传需求量最高的系统服务, 这样的结果就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;系统主服务的负担进一步减轻&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似服务统一处理, 专门优化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用上传服务的新功能的开发复杂度降低&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;系统模块化&#34;&gt;系统模块化&lt;/h3&gt;

&lt;p&gt;尽管静态文件相关的服务被剥离出来, 但是系统主服务还是太过庞大, 造成的影响包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有功能模块的集中, 导致开发修改任何功能都是对主服务的改动, 任何的微小 bug 都会导致主服务受影响&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于新成员, 无论开发功能还是修改 bug, 设计的代码范围大, 掌握系统设计的速度也比较慢&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于所有的资源都在同一个区域内, 功能开发很容易形成依赖, 如果开发成员的模块化意识差, 很容易写出混乱的代码, 给维护带来较大麻烦&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这些问题, 需要逐渐的将主服务中的功能进行拆分, 最终形成独立的功能服务.&lt;/p&gt;

&lt;h3 id=&#34;大前后端的分离&#34;&gt;大前后端的分离&lt;/h3&gt;

&lt;p&gt;一直以来, 后台管理系统与后台的数据服务是集合在主服务中的, 这样导致的问题就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;即使业务需求导致的页面变化非常微小, 也需要对主服务进行升级&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前端开发需要搭建和主服务同样的系统才能进行开发, 增大了开发难度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这两个问题, 对系统主服务中的前端部分拆分成单独的前端系统, 通过 API 的方式调用数据&lt;/p&gt;

&lt;h3 id=&#34;功能模块的拆分&#34;&gt;功能模块的拆分&lt;/h3&gt;

&lt;p&gt;功能服务独立化时面对的问题主要是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何确定功能的边界&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之前同一个服务进程内的依赖问题如何解决&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模块之间的数据如何同步&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-功能边界的确定&#34;&gt;1.功能边界的确定&lt;/h4&gt;

&lt;p&gt;这个需要从两个方面考虑:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总结出业务特点, 渐渐划清了模块的大体边界&lt;/li&gt;
&lt;li&gt;根据业务的变化及时调整&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-服务的数据依赖与同步&#34;&gt;2.服务的数据依赖与同步&lt;/h4&gt;

&lt;p&gt;将原来服务切分进行拆分, 之前简单的在内存中查找数据就可以完成的操作, 现在划分为多个流程的组合, 很多问题就会产生, 比如说中间出错怎么处理, 性能降低较大.&lt;/p&gt;

&lt;p&gt;直觉的处理方案就是技术替代. 这方面有很多技术上的解决方案, 比如 内部 Restful API, RPC 等等, 用这些技术手段替代之前的内存查找, 最起码从表面上完成了拆分.&lt;/p&gt;

&lt;p&gt;但是, 如果解决只是这个思路进行拆分, 我觉得有很大的浪费. 因为模块的划分, 本来就是从底层逼迫架构设计者考虑之前数据调用的合理性. 如果能够通过模块的划分, 将原来隐藏的问题暴露出来, 通过重新思考, 架构方案的改进从而对整个系统加以改进, 那对于系统的清晰和可维护性一定是个巨大的进步.&lt;/p&gt;

&lt;p&gt;对于模块独立后, 对于必须依赖的数据的同步, 我们采用的方案是中间件事件提醒, 然后从数据库查询同步的方案. 具体来说, 每一个模块都有自己的缓存数据, 每个模块都可能具有读和写的操作, 如果发生写操作, 那么在数据成功写入到数据库完成持久化以后, 需要发送一个对该数据发生变化的事件提醒到中间件, 依赖该数据的模块通过订阅该事件获得提醒, 之后通过查询数据库中的相关数据, 更新缓存数据.&lt;/p&gt;

&lt;h4 id=&#34;3-成果&#34;&gt;3.成果&lt;/h4&gt;

&lt;p&gt;系统模块化之后, 不仅解决了之前存在的问题, 还额外得到了另外一些好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于模块之间的数据依赖, 促使系统不断的向无状态, 内聚的方向进化, 系统之间的耦合性降低, 整个系统更加清晰, 为之后功能的开发提供了坚实的基础&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于每个模块负责管理自己的数据, 但整个系统对外提供的 API 需要提供跨模块的数据, 促使缓存层的单独设计, 同时将终端和后台的 API 进行了分类处理&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;系统的无缝升级&#34;&gt;系统的无缝升级&lt;/h3&gt;

&lt;p&gt;好长时间以来, 系统的升级维护工作都需要暂停服务, 暂停服务从公司业务管理制度上需要经历一系列的流程, 流程的繁杂会阻碍功能的及时升级, 这样会造成很多问题:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能不能快速上线, 会造成功能的堆积, 堆积增多与升级出错的概率成正比, 导致系统升级出现意外的可能性增大&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;功能不能及时上线, 功能的反馈及时性降低, 不能及时跟进客户真正需求, 时间成本增大&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;功能不能上线, 依据该功能的后续开发工作不确定性增大, 开发成本升高&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;体验差&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;造成这个问题的主要原因在于系统的缓存使用的是内存, 功能升级需要重新加载数据, 而多个实例内存级别实时数据同步的成本较高.&lt;/p&gt;

&lt;p&gt;为了解决这个问题, 系统模块中的缓存逐渐用 redis 替代, 通过将缓存与功能分离, 可以同时启动同一模块的多个实例, 通过负载均衡的配置, 可以逐步用升级版本的实例代替就实例, 实现无缝升级.&lt;/p&gt;

&lt;p&gt;另外一个好处就是, 再将模块缓存与功能分离后, 顺带实现了系统的横向扩展, 系统的承载量不再是问题&lt;/p&gt;

&lt;h3 id=&#34;向数据平台的演进&#34;&gt;向数据平台的演进&lt;/h3&gt;

&lt;p&gt;经过之前的改进, 整个系统在业务上基本不存在大的问题. 随着系统的增大, 和第三方资源的对接成为主要考虑的方向, 不仅包括接入第三方的数据资源, 也包括开发资源, 如何向第三方开放数据接口, 增大系统的功能扩展能力摆在面前.&lt;/p&gt;

&lt;p&gt;解决思路是整个系统向平台化演进. 将内部的各个模块在现有的业务层和数据层的基础上, 从纵向上进一步细化拆分, 业务层分为基础业务和组合业务, 数据层分为业务数据和基础数据, 每个层次上开放合适的 API服务, 第三方的开发能力在服务基础上, 就可以快速得以实现.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>怎样才能写出绝对的代码</title>
      <link>http://ssor.github.io/post/make_code_most_beautiful/</link>
      <pubDate>Sun, 19 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/make_code_most_beautiful/</guid>
      <description>&lt;p&gt;怎样写出无可指摘的代码
&lt;/p&gt;

&lt;h2 id=&#34;什么是绝对的代码&#34;&gt;什么是绝对的代码&lt;/h2&gt;

&lt;p&gt;任何人见到这套代码, 都不会说这个架构设计的不好, 这个代码还可以再优化一下. 最多可以说用另外一套架构可以完成同样的功能, 可以有另外的优点, 但是代价是牺牲当前这套架构的一些优点, 换句话说, 当前的代码实现了指定的功能, 具有某些优点, 已经没法子再改进, 一改进就是另外一套东西了&lt;/p&gt;

&lt;h2 id=&#34;具体方法&#34;&gt;具体方法&lt;/h2&gt;

&lt;h3 id=&#34;1-目标清晰具体&#34;&gt;1. 目标清晰具体&lt;/h3&gt;

&lt;p&gt;目标清晰的意义在于划定功能的边界, 边界确定的清晰, 功能代码就越清晰. 如果目标模棱两可, 那后人维护的时候就会以为某个功能做得不够全面, 而实际上是对功能的理解偏差&lt;/p&gt;

&lt;h3 id=&#34;2-思路简单到极致&#34;&gt;2. 思路简单到极致&lt;/h3&gt;

&lt;p&gt;没有人可以通过将功能变得复杂而使得代码让人无可指摘, 总可以通过添加一些代码实现新的功能. 只有在精简到极致的情况下, 才有可能让人无可再减, 也就无可指摘&lt;/p&gt;

&lt;h3 id=&#34;3-架构清晰&#34;&gt;3. 架构清晰&lt;/h3&gt;

&lt;p&gt;架构清晰的意义在于表现思路的简单. 模块组合简单合理, 没有冗余的模块, , 功能实现层次分明, 具有必须的模块和层次, 没有多余的层次抽象, 每个人都能看得懂, 最简单的做法就是按照当前的思路去实现.&lt;/p&gt;

&lt;h3 id=&#34;4-清晰的函数&#34;&gt;4. 清晰的函数&lt;/h3&gt;

&lt;p&gt;每个函数都是独立的, 每个函数的命名都很清晰, 每个函数的功能都很具体, 函数这些构成系统的细胞都很简单明确, 然后优美的组合成模块, 保证了系统底层的简单干净&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的编程理念</title>
      <link>http://ssor.github.io/post/how_to_program/</link>
      <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/how_to_program/</guid>
      <description>&lt;p&gt;我坚持用什么理念编程
&lt;/p&gt;

&lt;h2 id=&#34;简述&#34;&gt;简述&lt;/h2&gt;

&lt;p&gt;经过长时间的思考和实践, 我逐渐确立了以数据为核心, 面向概念的编程理念.&lt;/p&gt;

&lt;h2 id=&#34;核心点&#34;&gt;核心点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编程是以数据为核心, 是对数据的处理过程&lt;/li&gt;
&lt;li&gt;功能模型是分层次的, 每一层都是数据的一次转换&lt;/li&gt;
&lt;li&gt;每层是由一个核心概念和 N 个辅助概念构成的&lt;/li&gt;
&lt;li&gt;整个系统就是由一层层的转换组成, 数据经过层层转换, 输出需要的结果&lt;/li&gt;
&lt;li&gt;在每一层中, 每个概念实例的属性都是固定的, 可以更换概念的实例, 但不能改变其属性值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;

&lt;h3 id=&#34;数据作为思考核心&#34;&gt;数据作为思考核心&lt;/h3&gt;

&lt;p&gt;编程需求起步, 需求即一系列的功能组合. 而所谓功能, 无论对于基本的数据处理, 还是网络编程, 都是将原始数据结构转化成需要的数据结构的过程. 意识到这个本质, 就能去繁就简, 直面问题根源, 也不会因为功能负责而产生各种混乱&lt;/p&gt;

&lt;p&gt;因此, 功能明确后, 系统设计第一步就是, 明确功能需求, 确定起始数据结构和最终结果数据结构.&lt;/p&gt;

&lt;h3 id=&#34;分层模型&#34;&gt;分层模型&lt;/h3&gt;

&lt;p&gt;治理污水的过程包括物理处理, 化学处理, 生物处理, 一层层的过滤, 最终流出可以排放到自然的无害水.&lt;/p&gt;

&lt;p&gt;功能的分层就是对数据的一系列转换过程的组合, 每一次都可以认为是一个层次的转换. 在这个认识的基础上, 就可以根据需要设计组合出针对各种功能的分层模型&lt;/p&gt;

&lt;h3 id=&#34;核心概念&#34;&gt;核心概念&lt;/h3&gt;

&lt;p&gt;因为每一层对应一次数据的转换, 转换的过程以一个核心概念来表示, 围绕着概念的是转换过程所需要的参数设定和转换算法.&lt;/p&gt;

&lt;p&gt;对于每一个概念, 与其相关的方法可以使用概念实例所存储的属性值, 但这些属性值不能在使用过程中被改变, 因为一旦改变, 属性值就变成了状态值, 这就极大的降低了程序的可维护性, 也增加了程序出现 bug 的几率.&lt;/p&gt;

&lt;p&gt;对于需要改变的值, 一定要从外部输入, 并且尽量局限在小范围内使用. 同时, 这也意味着, 可以将这些变动提取成一个辅助概念, 将变化封装到辅助概念中, 核心概念的变化就转化成了对辅助概念实例的创建和销毁&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;p&gt;以上整个思考方法都是围绕着一个出发点进行: 通过抽象, 将问题拆分和独立, 针对每个问题进行深入研究.&lt;/p&gt;

&lt;p&gt;这个出发点符合人脑解决问题的特点. 人脑不善于同时处理很多问题, 但是善于抽象, 将问题通过抽象成类似树形的结构, 通过在每一层次上解决问题, 从而最终解决问题.&lt;/p&gt;

&lt;p&gt;在工程实践上, 按照以上思考方法的代码支持灵活的测试, 保证了代码的较高质量. 最重要的是, 由于最小的点足够小并且对外部的依赖小, 代码会非常清晰, 维护性会非常高.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mongo 数据库的合理使用</title>
      <link>http://ssor.github.io/post/rebuild_a_mongo_pool/</link>
      <pubDate>Sat, 11 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/rebuild_a_mongo_pool/</guid>
      <description>&lt;p&gt;如何防止 Mongo 数据库因为连接数过高导致异常
&lt;/p&gt;

&lt;h1 id=&#34;思路&#34;&gt;思路&lt;/h1&gt;

&lt;p&gt;防止 Mongo 连接数过高需要解决两个问题:
1. 如何限制应用使用的连接数
2. 应用如何合理使用有限的连接&lt;/p&gt;

&lt;p&gt;对于第一个问题, 现在的处理方案是使用连接池, 在连接池内设定最高数量的连接, 重复利用而不随意增多, 从而从整体上保证了连接的数量&lt;/p&gt;

&lt;p&gt;但是, 如果之前的应用中使用连接的方式根本没有考虑连接资源有限的话, 改造起来相对麻烦一些. 很多的应用对连接数使用数量来源于业务访问量, 新增一个访问量, 则简单的新创建一个连接, 等于将业务的访问压力转嫁到数据库上, 为系统的稳定埋下了隐患. 因此, 对于应用内使用有限连接的方式, 从两个角度解决:
1. 强制使用有限连接, 如果因为连接数暂时不够导致业务无法及时处理, 将业务推迟, 由业务发起方重新请求
2. 对于无法推迟的业务处理, 将请求缓存, 使用有限连接排队处理请求&lt;/p&gt;

&lt;h1 id=&#34;基本连接池&#34;&gt;基本连接池&lt;/h1&gt;

&lt;h2 id=&#34;连接池的好处&#34;&gt;连接池的好处&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;连接 Mongo 时, 如果连接太多, 会导致数据库因并发连接太多而崩溃;&lt;/li&gt;
&lt;li&gt;如果 Mongo 采用了 Primary 和 Secondary 模式, 会导致各个实例的角色不断转换, 从而导致数据不停的在各个实例之间同步, 不仅造成了服务器的负担, 而且导致数据库出错的概率急剧增大, 甚至导致整个系统的运行出错.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这个问题, 就要限制各个应用连接 Mongo 的连接数量, 应用于&lt;a href=&#34;https://github.com/ssor/mongopool&#34;&gt;生产环境的库&lt;/a&gt;, 基于 Go 开发&lt;/p&gt;

&lt;h2 id=&#34;支持特性&#34;&gt;支持特性&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;限制了应用并发连接数量&lt;/li&gt;
&lt;li&gt;数据库断线自动重连&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;如何查看连接数量&#34;&gt;如何查看连接数量&lt;/h2&gt;

&lt;p&gt;linux :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo netstat -apn | grep 27107
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;macOS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo lsof -nP -iTCP  | grep mongo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;连接池原理&#34;&gt;连接池原理&lt;/h2&gt;

&lt;h3 id=&#34;数量限制&#34;&gt;数量限制&lt;/h3&gt;

&lt;p&gt;每次需要创建连接时, 首先申请一个连接, 如果已经超过了一定数量, 则请求被驳回, 也就是不能创建新连接, 从而达到了限制连接数量的目的&lt;/p&gt;

&lt;h3 id=&#34;数据库断线重连&#34;&gt;数据库断线重连&lt;/h3&gt;

&lt;p&gt;数据库需要重启时, 不需要要重新启动应用.&lt;/p&gt;

&lt;p&gt;当操作数据库失败时, 启动之前创建的连接的刷新流程&lt;/p&gt;

&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;参照该库提供的&lt;a href=&#34;https://github.com/ssor/mongopool/blob/master/example/main.go&#34;&gt;例子&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;支持事务的连接池&#34;&gt;支持事务的连接池&lt;/h1&gt;

&lt;p&gt;Mongo 本身不支持事务, 但是通过利用 Mongo 本身的一些特性, 可以使其支持简单的事务处理. 这是一个&lt;a href=&#34;https://github.com/ssor/mongo_pool_txn&#34;&gt;应用于生产环境的库&lt;/a&gt;, 敬请参考&lt;/p&gt;

&lt;h1 id=&#34;额外的开源计划&#34;&gt;额外的开源计划&lt;/h1&gt;

&lt;p&gt;对于具体如何解决之上, 之后会考虑开源一个实用的实例, 敬请期待&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>不用逻辑流程图交流思想</title>
      <link>http://ssor.github.io/post/do_not_use_logic_flow_chart/</link>
      <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/do_not_use_logic_flow_chart/</guid>
      <description>&lt;p&gt;逻辑流程图是人与人之间交流的障碍&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是逻辑流程图&#34;&gt;什么是逻辑流程图&lt;/h2&gt;

&lt;p&gt;用图表示的算法就是流程图。流程图是用一些图框来表示各种类型的操作，在框内写出各个步骤，然后用带箭头的线把它们连接起来，以表示执行的先后顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ssor.github.io/img/logic_flow.gif&#34; alt=&#34;流程图样例&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么不用逻辑流程图&#34;&gt;为什么不用逻辑流程图&lt;/h2&gt;

&lt;p&gt;我非常讨厌那些看似工工整整的流程图, 因为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果我获取其中所要表达的意思, 那我必须仔细的去思考里面的是否条件, 记住一整套的逻辑, 最后才能在脑中构建起一长串的意思.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更让我讨厌的是, 如果过一段时间其中任何一个环节忘记了, 那基本需要重新来一遍.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果想要对别人描述一下里面的内容, 那就必须从头到尾说一遍, 而且因为分支的原因, 在描述过程中必须有一系列的分支点, 万一听你描述的人把其中的一个分支点忘记了, 那么, 好吧, 把这个分支节点之前的逻辑重新讲一遍.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么会是这样?&lt;/p&gt;

&lt;h3 id=&#34;逻辑是计算机的思维方式&#34;&gt;逻辑是计算机的思维方式&lt;/h3&gt;

&lt;p&gt;计算机因为基于电子正负特性, 最底层的逻辑只有是否两种, 因此为了让计算机识别复杂的逻辑, 必须将复杂逻辑转换成基本的是否逻辑. 从这个角度来说, 是否逻辑是计算机的逻辑. 可以说, 逻辑流程图的出现是历史原因造成的.&lt;/p&gt;

&lt;p&gt;计算机刚出现的时候, 计算机语言相对比较难懂, 需要专门经过训练的人, 才能编写出计算机能识别的代码. 只是编写能让计算机识别的代码就如此困难, 因此很难将算法的设计工作也放到同一个人身上. 在这种情况下, 社会分工协作导致出现了专门的计算机工程师和算法设计师. 算法设计师表达算法的最合适的方式, 就是尽量让计算机工程师不需要思考太多,就可以按照表达式翻译成计算机代码, 从而在整体效率上达到最优. 这个表达方式就是逻辑流程图.&lt;/p&gt;

&lt;p&gt;逻辑流程图使用是否分支描述复杂的逻辑, 因为非常接近计算机的思维方式 所以很容易翻译成计算机能识别的逻辑. 对于软件的思路描述, 普通的编程语言都具有基本的逻辑关键字, 一个基本掌握该语言的程序员, 将流程图一步一步的翻译成代码, 然后编译成软件, 就可以完成编程任务了.&lt;/p&gt;

&lt;p&gt;逻辑流程图流传到现在慢慢地出现了问题. 随着计算机技术的发展, 出现了很多高级编程语言, 能够让普通人完成之前需要经过专业训练才能完成的编码工作. 因此, 原来专门负责将算法翻译成代码的工作大部分其实已经消失, 现在的计算机工程师已经是之前计算机工程师和算法设计师的合体. 现在的软件工程师面对的是功能性的需求, 了解了需求后, 软件工程师负责设计算法, 并通过软件的方式展现结果. 一般需求的提出者是人, 也就是说软件工程师交流的对象是人, 这和之前计算机工程师与算法设计师的交流根本不是一个层次, 从这个角度来说, 不经思考的沿用之前的交流方式的话, 就是现实版的刻舟求剑了.&lt;/p&gt;

&lt;p&gt;如果我们把需求提出方设定为产品经理, 那么, 逻辑流程图到底适不适合产品经理与软件工程师的交流呢? 这需要从职能方面来分析. 一般来说, 产品经理经过对业务的分析, 提出了一个软件应有的表现, 也就是规定了软件的用户进行相关操作后, 软件应该输出怎样的结果, 即产品经理提出了一个输入输出的定义, 中间的实现过程并不关心. 负责实现的是软件工程师. 分析后发现, 产品经理所描述的软件动作, 不重实现, 而重表现. 对产品经理来说, 只要一个列表的结构, 就能表达出完整的需求, 里面没有逻辑. 如果产品本身有一定的逻辑, 这个逻辑也可以转成简单的列表. 综合以上分析, 逻辑流程图其实并不适合作为交流中间形式.&lt;/p&gt;

&lt;h3 id=&#34;人类的思维方式是概念抽象思维&#34;&gt;人类的思维方式是概念抽象思维&lt;/h3&gt;

&lt;p&gt;人类的最强大的思维方式是抽象思维. 人类大脑不擅长处理长串列表, 而通过抽象思维, 可以将列表分类抽象, 最后通过类似树形的方式进行高效处理, 其中所谓的归类我们一般称之为概念. 通过定义一系列的概念, 及其相互之间的关系, 构造出对事物理解的模型, 大脑通过对模型的认识和思考和现实世界进行交互. 通过不断的更新概念体系, 更新模型运转逻辑, 不断的逼近现实世界, 通过这种方式, 理论上, 人类最终可以真正的认清现实世界.&lt;/p&gt;

&lt;p&gt;在长期的进化和练习后, 人类大脑可以高效的通过概念进行交流.&lt;/p&gt;

&lt;h2 id=&#34;应该用什么交流&#34;&gt;应该用什么交流&lt;/h2&gt;

&lt;p&gt;用文字描述. 通过语言的描述, 并且通过落实到具体的文字, 加强描述的精确性; 如果要求再高, 那就是通过给不同的人讲解, 通过人是否容易理解文字所描述的意义来测试文字描述是否清晰.&lt;/p&gt;

&lt;p&gt;另外, 如果功能上对具体的数字有要求, 建议增加测试用例, 软件开发完成后, 通过数据进行最终的判定, 保证功能开发符合需求&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Consul在服务发现中的应用</title>
      <link>http://ssor.github.io/post/how_to_use_consul/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/how_to_use_consul/</guid>
      <description>&lt;p&gt;Consul的基本原理及其在服务发现中的使用&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;服务发现&#34;&gt;服务发现&lt;/h2&gt;

&lt;p&gt;服务发现,通俗的讲,就是通过关键字查询特定的服务.&lt;/p&gt;

&lt;h2 id=&#34;服务发现的意义&#34;&gt;服务发现的意义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果服务本身发生了变化, 只需要更新服务即可, 与服务相关的关键字不变, 因此服务的使用者不需要关心该变化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务进行升级后, 如果服务要求的参数不变(平滑升级可以做到), 服务使用者只需要用新的关键字替换之前的关键字即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同一个服务的多个版本可以同时存在, 使用者可以根据需求方便的切换版本&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;consul-是什么&#34;&gt;Consul 是什么&lt;/h2&gt;

&lt;p&gt;Consul是 &lt;a href=&#34;https://www.hashicorp.com/&#34;&gt;HashiCorp&lt;/a&gt;开发的用于服务发现的系统. 它的主要特性有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持通过 DNS 和 HTTP 发现服务&lt;/li&gt;
&lt;li&gt;提供服务的健康检查&lt;/li&gt;
&lt;li&gt;键值存储&lt;/li&gt;
&lt;li&gt;多数据中心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过服务发现的方式为使用者提供服务, 稳定是最重要的考虑因素, Consul 的去中心化的多节点提供稳定的服务. 同时因为健康检查的存在, 可以保证服务的有效性.&lt;/p&gt;

&lt;h2 id=&#34;consul-的部署&#34;&gt;Consul 的部署&lt;/h2&gt;

&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;

&lt;p&gt;每台服务器上至少有一个 Consul 的节点( Agent ), 节点有两种模式: 服务器模式和客户端模式.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器模式提供服务注册和查找等功能, 是 Consul 去中心化的关键节点,推荐至少部署三个节点.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端模式负责转发服务请求到服务器模式的节点.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于两种模式的节点负责功能的不同, 可以假设客户端模式的节点是稳定存在的, 而服务器模式的节点可能会异常退出.&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;根据系统&lt;a href=&#34;https://www.consul.io/downloads.html&#34;&gt;下载&lt;/a&gt;合适的版本, 并解压至合适的目录.&lt;/p&gt;

&lt;p&gt;假设有4台服务器, IP分别为 &lt;strong&gt;172.16.1.34&lt;/strong&gt;, &lt;strong&gt;172.16.1.35&lt;/strong&gt;, &lt;strong&gt;172.16.1.37&lt;/strong&gt;, &lt;strong&gt;172.16.1.69&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将在 34, 35, 69 上启动服务器模式节点, 在37上启动客户端模式节点, 启动命令如下:&lt;/p&gt;

&lt;h5 id=&#34;34&#34;&gt;34&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;./consul agent -server -bootstrap-expect=3 -node=agent34 -data-dir=./ &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;35&#34;&gt;35&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt; ./consul agent -server -bootstrap-expect=3 -node=agent35 -data-dir=./ &amp;amp;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;69&#34;&gt;69&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt; ./consul agent -server -bootstrap-expect=3 -node=agent69 -data-dir=./ &amp;amp;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;37&#34;&gt;37&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt; ./consul agent  -node=agent37 -retry-join=172.16.1.35 -data-dir=./ &amp;amp; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在35和34服务器上运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ./consul join 172.16.1.69 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三个服务器模式节点将选出一个 leader, 服务启动完成.&lt;/p&gt;

&lt;p&gt;查看一下节点状态, 运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ./consul members 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果类似如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node     Address           Status  Type    Build  Protocol  DC
agent34  172.16.1.34:8301  alive   server  0.7.2  2         dc1
agent35  172.16.1.35:8301  alive   server  0.7.2  2         dc1
agent37  172.16.1.37:8301  alive   client  0.7.2  2         dc1
agent69  172.16.1.69:8301  alive   server  0.7.2  2         dc1

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;h5 id=&#34;使用http-api&#34;&gt;使用HTTP API&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注册服务 &lt;a href=&#34;https://www.consul.io/docs/agent/http/agent.html#agent_service_register&#34;&gt;/v1/agent/service/register&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找服务 &lt;a href=&#34;https://www.consul.io/docs/agent/http/health.html#health_service&#34;&gt;/v1/health/service/&lt;service&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;使用-sdk&#34;&gt;使用 SDK&lt;/h5&gt;

&lt;p&gt;系统中使用 Consul 需要对其 HTTP API 进行封装, 因此可以直接使用官方封装的 Go 版的 SDK&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注册服务 参考&lt;a href=&#34;https://github.com/ssor/consul_service_reg/blob/master/main.go&#34;&gt;代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找服务 参考&lt;a href=&#34;https://github.com/ssor/consul_query_service_example/blob/master/main.go&#34;&gt;代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;基本的使用方法介绍完毕, 下一步将对实际工程中的使用问题进行补充&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小书包在线聊天系统架构演进</title>
      <link>http://ssor.github.io/post/architechure_desigin_of_chat/</link>
      <pubDate>Wed, 05 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/architechure_desigin_of_chat/</guid>
      <description>&lt;p&gt;介绍小书包聊天系统的架构历史及发展方向&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;技术方案&#34;&gt;技术方案&lt;/h2&gt;

&lt;p&gt;开发在线聊天功能考虑的第一个问题是: 能不能用第三方的系统?&lt;/p&gt;

&lt;p&gt;第三方的系统已经有成熟的商业解决方案, 自行开发成本很高. 但问题在于:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果经过第三方系统, 数据安全方面能不能得到保证&lt;/li&gt;
&lt;li&gt;如果要对聊天内容进行限制, 第三方系统是否能够做到&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过调研, 发现上面两个问题基本很难解决.&lt;/p&gt;

&lt;p&gt;那么能不能用开源的系统? 有许多具有很多应用案例的组合可以选择. 但是经过研究发现, 这些系统在部署和维护上也需要较大的投入, 再结合我们的技术选型和初期的产品需求, 发现自己开发一个反而成本较低, 而且后期也可以按照业务需求灵活改动.&lt;/p&gt;

&lt;h3 id=&#34;单例&#34;&gt;单例&lt;/h3&gt;

&lt;p&gt;初期的产品需求比较简单, 只要登录的人能够在群内互相发送消息即可, 不需要群的管理和消息的持久化&lt;/p&gt;

&lt;p&gt;所以第一版的在线聊天经过几天的开发就可以使用了. 它的功能包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户上线时, 访问服务, 服务根据用户属性, 将其分配到预设的群中&lt;/li&gt;
&lt;li&gt;用户发送消息, 该消息会通过 websocket 转发给群内的其他成员&lt;/li&gt;
&lt;li&gt;支持文字, 图片和语音&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一版在一台服务器上满足了十万人左右的聊天需求&lt;/p&gt;

&lt;h3 id=&#34;多节点&#34;&gt;多节点&lt;/h3&gt;

&lt;p&gt;用户量的增多对系统提出了更多的挑战, 主要有以下几个:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户量增大, 单个服务器难以承载&lt;/li&gt;
&lt;li&gt;登录过程较慢, 系统升级造成服务的中断&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这些问题, 系统在架构上进行以下的改进:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;预先创建群&lt;/li&gt;
&lt;li&gt;分配服务器节点和聊天功能进行模块上的分离, 分别由不同的服务负责, 各个模块可以单独部署&lt;/li&gt;
&lt;li&gt;用户登录采用两段式, 即先获取分配服务器节点, 通过分配服务器获取登录节点, 最终在分配的登录服务器节点上登录&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;改造完成后, 用户量承载方面已经没有问题, 由于多节点的支持, 用户登录也较为快速, 基本解决问题&lt;/p&gt;

&lt;h3 id=&#34;高可用&#34;&gt;高可用&lt;/h3&gt;

&lt;p&gt;随着用户分布范围的扩大, 遇到的网络情况变得复杂起来; 同时对服务的可用性也提出了更高的要求. 这种情况下需要解决的问题有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器分配节点的服务器失效&lt;/li&gt;
&lt;li&gt;终端对外网络有限制, 无法连接到服务器&lt;/li&gt;
&lt;li&gt;用户分配的节点服务器失效或者系统升级重启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决上述问题, 系统进行了如下改进:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端路由和分配服务器多点
&amp;gt; 客户端进行第一段的登录请求时, 获取的将会是一组分配服务器地址, 客户端轮询服务器列表, 其中一个失效不会阻碍登录的进行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户群在各个聊天节点的自动迁移, 解决了节点升级和失效的问题&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;未来计划&#34;&gt;未来计划&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用户消息的持久化&lt;/li&gt;
&lt;li&gt;用户群在节点间迁移, 消息自动同步&lt;/li&gt;
&lt;li&gt;跳出聊天的范畴, 成为一个数据传输管道&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>如何冥想</title>
      <link>http://ssor.github.io/post/how_to_meditation/</link>
      <pubDate>Mon, 12 Sep 2016 20:45:58 +0800</pubDate>
      
      <guid>http://ssor.github.io/post/how_to_meditation/</guid>
      <description>&lt;p&gt;介绍我对冥想作用的理解, 以及如何冥想&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;冥想的定义&#34;&gt;冥想的定义&lt;/h2&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://en.wikipedia.org/wiki/Meditation&#34;&gt;WIKI 中关于冥想的定义&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;冥想的意义&#34;&gt;冥想的意义&lt;/h2&gt;

&lt;h3 id=&#34;1-让大脑得到休息&#34;&gt;1. 让大脑得到休息&lt;/h3&gt;

&lt;p&gt;冥想的实质在于把大脑真正的当做一个器官，用来思考的器官，在这个器官运动了长时间之后，使其进入恢复期。&lt;/p&gt;

&lt;p&gt;这就像电脑的CPU在长时间高负荷的运作之后，运作过程中产生的热量如果不能及时的发散出去，就会进入保护性的死机的道理一致。&lt;/p&gt;

&lt;p&gt;但是，大脑肯定是比目前的人造品高级得多的，那就是如果我们的大脑像肌肉一样，通过长时间的锻炼，可以不断的得到加强，最后的运转效率可能是原先的几倍。要实现这个，就必须要像锻炼肌肉一样，有张有弛。平常的思考使用就是张，那么冥想就是驰，这样劳逸结合，就会不断地进步。&lt;/p&gt;

&lt;h3 id=&#34;2-客观的对待环境&#34;&gt;2. 客观的对待环境&lt;/h3&gt;

&lt;p&gt;冥想做到一定阶段，就能够区分自我和本我，自我是大脑控制的，而本我是真正的我。能够区分自我和本我之后，就能够区分哪些是大脑的经验性反应，哪些是不受经验约束的正确反应，这样就能保证我们按照正确的思考行动。&lt;/p&gt;

&lt;h2 id=&#34;如何冥想&#34;&gt;如何冥想&lt;/h2&gt;

&lt;p&gt;李笑来在这方面专门写了一篇&lt;a href=&#34;http://zhibimo.com/read/xiaolai/zuo-xiang-qi-cheng/index.html&#34;&gt;文章&lt;/a&gt;, 非常好, 推荐阅读&lt;/p&gt;

&lt;h3 id=&#34;步骤&#34;&gt;步骤&lt;/h3&gt;

&lt;p&gt;我觉得步骤可以简单到:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开始深呼吸&lt;/li&gt;
&lt;li&gt;将自己所有的注意力全部集中到呼吸上&lt;/li&gt;
&lt;li&gt;一旦发现注意力转移到其它地方，就要刻意地将注意力集中到呼吸上&lt;/li&gt;
&lt;li&gt;持续深呼吸……&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;阶段&#34;&gt;阶段&lt;/h3&gt;

&lt;p&gt;随着冥想的进行, 有很多不同的阶段&lt;/p&gt;

&lt;h4 id=&#34;1-初级阶段&#34;&gt;1. 初级阶段&lt;/h4&gt;

&lt;p&gt;只专注于自己的呼吸, 排斥任何其它想法&lt;/p&gt;

&lt;h4 id=&#34;2-二级阶段&#34;&gt;2. 二级阶段&lt;/h4&gt;

&lt;p&gt;意识到有好多个想法来吸引注意力, 但是能够通过专注呼吸的方法, 控制注意力不被吸引&lt;/p&gt;

&lt;h4 id=&#34;3-三级阶段&#34;&gt;3. 三级阶段&lt;/h4&gt;

&lt;p&gt;能够选择特定的想法跟踪想法的来源, 直到认清整个想法,也就是认识真正的自己, 并且在任意时刻, 可以从想法中脱离, 不会陷入胡思乱想&lt;/p&gt;

&lt;h4 id=&#34;4-四级阶段&#34;&gt;4. 四级阶段&lt;/h4&gt;

&lt;p&gt;认识真正自己的前提下, 能够改造自己的潜意识, 客服弱点, 更新自己&lt;/p&gt;

&lt;h4 id=&#34;5-五级阶段&#34;&gt;5. 五级阶段&lt;/h4&gt;

&lt;p&gt;尚未可知&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后台开发选择了 Go 语言</title>
      <link>http://ssor.github.io/post/why_use_golang_for_backend/</link>
      <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/why_use_golang_for_backend/</guid>
      <description>&lt;p&gt;经过认真思考, 还是选择了 Go 作为主力开发语言
&lt;/p&gt;

&lt;p&gt;后台开发语言的可选项很多, 最没有错误的选择是 Java, 还有 JVM 平台的其它言语 Scala, closure也有大牛在用, 尽管如此, 这些语言各自存在着不同的问题. 与此同时, 也有很多的新语言不断涌现, 试图解决之前语言在开发中遇到的问题. 新语言的问题在于尚未经过时间的检验, 对于产品的开发可能存在风险, 因此需要在风险和新语言的特性之前做出权衡. 我们遇到的是 Go 语言与其它语言.&lt;/p&gt;

&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;

&lt;h3 id=&#34;开源&#34;&gt;开源&lt;/h3&gt;

&lt;p&gt;一定要选择开源的编程语言. 不是因为可以自己往语言里加自己想要的特性, 而是因为, 无论在什么情况下, 不会突然发生语言无人维护的情况; 如果官方放弃该语言, 在确实需要的情况下, 可以自行维护, 保证对已开发系统的支持.&lt;/p&gt;

&lt;h3 id=&#34;设计简单&#34;&gt;设计简单&lt;/h3&gt;

&lt;p&gt;代码直观, 没有各种类的理论的设定, 没有各种看起来很有效率的特性, 代码阅读更流畅, 很难产生误解, 易于维护.&lt;/p&gt;

&lt;h3 id=&#34;快速的静态编译&#34;&gt;快速的静态编译&lt;/h3&gt;

&lt;p&gt;在构建复杂的后端系统时, 在当前阶段, 静态编译在消除隐藏问题方面有着很大的优势, 可以减少大量的测试, 保证系统稳定的同时, 极大的提高开发效率.&lt;/p&gt;

&lt;h3 id=&#34;跨平台编译&#34;&gt;跨平台编译&lt;/h3&gt;

&lt;p&gt;系统的部署一直是个很大的问题, 世界上最好的语言 PHP 之所以最好有一部分原因是跨平台, 在 windows 下开发完成后, 直接部署在 linux 服务器上, 表现基本一致. 相比来说, Go 在这方面的优势只大不小. 在 macOS 上开发完成后, 可以直接编译为 linux 上运行的二进制包, 跨平台表现的一致性更强. 同样的系统不需要任何修改就可以跨平台运行, 极大的降低了开发成本.&lt;/p&gt;

&lt;h3 id=&#34;健壮全面的标准库&#34;&gt;健壮全面的标准库&lt;/h3&gt;

&lt;p&gt;Go 的发布同时带来了健壮齐全的标准库, 一般的系统都不需要额外的外部库依赖, 对生态发展的依赖性极低. 标准库的维护和升级兼容性工作由设计者维护, 保证了系统升级时的稳定可靠.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>赚取财富的秘密</title>
      <link>http://ssor.github.io/post/secret_of_make_money/</link>
      <pubDate>Tue, 15 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/secret_of_make_money/</guid>
      <description>&lt;p&gt;怎么赚钱？
&lt;/p&gt;

&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;

&lt;p&gt;财富的获取是通过交换实现的, 必须生产出能够用于交换的产品, 并成功进行了交换.&lt;/p&gt;

&lt;p&gt;在基于某产品的交换模式发展过程中, 可能会产生各种复杂的表现形态, 但是核心的指标只有两个: 单价和数量.&lt;/p&gt;

&lt;p&gt;根据产品的特性, 由这两个指标衍生出重要的商业模式多种多样, 一般有两个极端: 偏重单价和偏重数量&lt;/p&gt;

&lt;h2 id=&#34;两种模式&#34;&gt;两种模式&lt;/h2&gt;

&lt;h3 id=&#34;单价高-数量少&#34;&gt;单价高, 数量少&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;适合不能低成本复制的产品&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;数量多-单价低&#34;&gt;数量多, 单价低&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;适合能够低成本复制的产品&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其余各种模式在这两种模式之间徘徊&lt;/p&gt;

&lt;h2 id=&#34;核心&#34;&gt;核心&lt;/h2&gt;

&lt;p&gt;能够获取利润的种子, 也就是能够用于交换的产品, 然后乘上数量&lt;/p&gt;

&lt;p&gt;前者是1, 后者是 0. 没有1, 多少个0都是0; 有了1, 后面每添加一个0, 就高一个数量级&lt;/p&gt;

&lt;h2 id=&#34;寻找那个1&#34;&gt;寻找那个1&lt;/h2&gt;

&lt;p&gt;研究现实的需求, 设计能够满足需求的产品&lt;/p&gt;

&lt;h2 id=&#34;增大数量级&#34;&gt;增大数量级&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;为产品的批量低成本复制寻找方法&lt;/li&gt;
&lt;li&gt;找到产品大量推广的市场&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>如何获取初创点子(Paul Graham)</title>
      <link>http://ssor.github.io/post/how_to_get_startup_ideas/</link>
      <pubDate>Sun, 12 Jul 2015 20:45:58 +0800</pubDate>
      
      <guid>http://ssor.github.io/post/how_to_get_startup_ideas/</guid>
      <description>&lt;p&gt;讲述了作者对于如何获取正确的创业点子的思路.&lt;br /&gt;
(翻译:张全志, 原文链接: &lt;a href=&#34;http://paulgraham.com/startupideas.html&#34;&gt;http://paulgraham.com/startupideas.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何获取初创点子&#34;&gt;如何获取初创点子&lt;/h2&gt;

&lt;p&gt;获取初创点子的方法不是试着去想出一些点子，而应该是去试着发现问题，特别是你本身就在经历的问题&lt;/p&gt;

&lt;p&gt;最好的初创点子一般有三个共性：这个点子本身就是初创者需要的，初创者自身就能实现，并且很少有别人意识到这个事情值得去做。微软、苹果、雅虎、谷歌和Facebook都是这么开始的&lt;/p&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;为什么解决自己的问题这么重要？最重要的一个原因就是这保证了这个问题是确实存在的。这么说的意思是你应该解决确实存在的问题，但确实初创中最常见的错误就是去解决根本不存在的问题。&lt;/p&gt;

&lt;p&gt;我自己就犯过这个错误。1995年我创立了一家公司，公司的业务是将艺术展览品放到网络上。但展览馆根本就不想将自己放到网络上，因为那样根本不是展览馆运营的方式。那我当时为什么为这个愚蠢的点子花费了六个月的时间。因为当时我根本没有思考用户的需求。我发明了一个现实中根本不存在的模型，并试着让它起作用。但我根本没有意识到我的模型是错误的，直到我尝试让我的用户为我的产品付钱。尽管如此，我还花了好长时间让用户接受它。我只是想着：我为这个模型花费了这么长的时间，所以他们必须需要它！&lt;/p&gt;

&lt;p&gt;为什么这么多的初创者创立了这么多没人需要的产品？因为他们初创的开端是试图想出一个初创的点子。这种操作模式（m.o. mode of operation）毫无疑问很危险，因为这样不仅几乎不会想出什么好点子，更会产生一些貌似合理的，足够迷惑你去白费力气的点子。&lt;/p&gt;

&lt;p&gt;在YC我们将这些点子称为捏造或者情景剧式点子。想象电视剧中的一个角色的创作，这个角色要做的事情都是编剧们编写出来的。但是提出真正的好的初创点子很难，这不是请求一下就能解决的问题。所以，除非他们有不可思议的好运气，否则编剧们最终提出的点子只是听起来合理，但实际上不是这样。&lt;/p&gt;

&lt;p&gt;以宠物社交网络为例，这个点子听上去没有那么明显的错误，因为许多人养有宠物，并且宠物主人很在意它们，为宠物也花了很多钱，那么当然会有一部分人希望有一个这样的一个宠物主人之间可以交流的网站。不需要全部都参与进来，只需要百分之二或者三的人经常访问，这个网站就有了上百万的用户，你就可以为他们提供针对性的服务，还可以通过一些高级功能收费&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;这样的点子的危险性在于，当你向你的养宠物的朋友询问意见时，他们不会说“我永远不会用这个”，相反他们会说，“嗯，不错，也许我会用一下这个产品”。即使当这个产品真正运行起来，对好多人也会显得非常合理。他们自己不会用，至少现在是这样，但是他们会想象别人可能需要这个产品，最后所有的人都这么反应，这个产品就不会有用户&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;井&#34;&gt;井&lt;/h2&gt;

&lt;p&gt;当一个产品启动后，必须至少有一些真正并且迫切需要它的用户存在，而不是一些只是想想可能有一天会用到的人。通常这第一批用户会很少，原因很简单，如果有很多人有这个需求，而这个需求只要一个小小的初创团队就能完成一个雏形，那这个产品早就应该存在了。这就意味着你必须做出一定的选择，是选择做一个面向大量用户但满足小部分需求的产品，还是做一个面向少量用户但是满足大部分需求的产品。选择后者为好，虽然不一定这种类型的点子都是好点子，但是几乎所有好的点子都是这种类型。&lt;/p&gt;

&lt;p&gt;想象一个这样的图表，X轴代表需要你的产品的用户，Y轴代表产品满足需求的程度，如果将Y轴的比例尺反转，你会看到公司成了一个个的洞。在这张图上，谷歌就是一个巨大的火山口，成千上万的人使用它，并且满足了使用的人的大部分需求。而一个新创企业无法达到这么大的量。所以你就有两个选择，你可以让你的公司在图表上的洞宽广但是浅薄，也可以让它窄小但是深邃，就像一口井。&lt;/p&gt;

&lt;p&gt;捏造出来的点子通常都是第一种类型，因为很多人对宠物社交网络只是有一点点兴趣。&lt;/p&gt;

&lt;p&gt;几乎所有的好点子都是第二种类型的。微软当年做出了Altair Basic语言，而当时只有两千多人Altair用户，但是如果没有微软的这个工具，这些用户就只能在他们的电脑上使用机器语言编程。三十年后，同样地一幕在Facebook上重演，这个网站一开始只为哈佛大学的几千名学生服务，但是这个学生都很需要这个网站。&lt;/p&gt;

&lt;p&gt;当有一个初创点子时，首先问问自己：哪些人现在需要这个？即使这个产品只是由从来没听说过的两个人创始团队做出来的，体验还相当差，哪些人也会迫不及待的使用它？如果回答不了这两个问题，那这个点子基本就不怎么样了&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;你的这口井并不是一定要窄小，关键是你需要它的深度，窄小只是深度的副产品，虽然几乎总是这样。实际上这两种属性强烈的相关性是种好现象，这标志着这个点子非常贴合一群或者一类用户的需要。&lt;/p&gt;

&lt;p&gt;尽管对好的点子来说，需求形状像一口井几乎是必须的，但还不够。如果Mark Zuckerberg只是倾向于为哈佛学生服务，那就不是一个好点子了。Facebook是一个好点子是因为它以一个小市场开始，但是通过这个小市场可以很快的进入大市场中去。大学在很多方面是相似的，所以如果这个东西在哈佛大学受欢迎，那在别的大学也可以。一旦你拥有了所有大学的学生，再让别人进来就很简单了。&lt;/p&gt;

&lt;p&gt;同样对微软来说，Basic语言的Altair版，之后就是别的机器的版本，然后就是别的语言，之后就是操作系统，再然后就是系统的各种应用，然后上市。&lt;/p&gt;

&lt;h2 id=&#34;自己&#34;&gt;自己&lt;/h2&gt;

&lt;p&gt;那么如何知道一个点子是否能做大？如何确定这个点子是一个巨大公司的萌芽，还是只是个小众产品？通常来说，没法分辨。Airbnb的创始人一开始没有意识到他们打开了一个巨大的市场，他们只有一个简单地想法而已，只是想让房东们在方便的时候可以将自己的房子出租出去，他们并没有高瞻远瞩的预见到这个点子的可扩展性，只是这个点子逼迫他们逐渐意识到这个。他们一开始只知道他们在做一些事，这个和Bill Gates还有Mark Zuckerberg一开始的想法相似。&lt;/p&gt;

&lt;p&gt;偶尔的我们可以从一个初始的小市场产品很明显的看到通向大市场的路，然而有时又不会马上看出来，这也是YC中的企业的一个特质。不管你经验有多丰富，这方面都有很大的局限性。这里最重要的是意识到初创点子的可发展的道路很难一开始就能看到。&lt;/p&gt;

&lt;p&gt;所以，如果你无法预测点子的可发展性，那你怎么在那么多点子里进行抉择呢？结果很让人失望，但是也很有意思，那就是：如果你是这种人，那你就会有直觉。如果你处于一个变化迅速的领域的前沿，并且你有一个直觉，某件事应该去做，那么这基本上就是正确的&lt;/p&gt;

&lt;p&gt;在 Zen and the Art of Motorcycle Maintenance中, Robert Pirsig 说：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;你想知道如何画出完美的画吗？很简单，将自己变得完美，然后你自然就知道答案了&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从我在高中读到这句话时，我就一直在考虑他的深意。虽然我无法确定在绘画方面是否有效，但在初创方面非常合适。实际上，找到好的初创点子的方法就是变成拥有好点子的人。&lt;/p&gt;

&lt;p&gt;在一个领域的前沿并不意味着你必须推动该领域发展，你也可以作为该前沿领域的用户。并不是因为Mark Zuckerberg 是一名程序员，Facebook就是一个好点子，而是因为他已经习惯了有电脑的生活。你可以问一下2004年四十多岁的人，他们是否愿意在网上半公开自己的生活，他们一定会被这个想法吓到的。但是Mark已经生活在网上了，对他来说，这个点子很自然。&lt;/p&gt;

&lt;p&gt;Paul Buchheit 说过，处于变化迅速的领域前沿的人“生活在未来中”。与Pirsig所说的结合起来就是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;活在未来中，做还缺少的东西&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这句话道出了几乎所有伟大初创活动如何开始的基本原理。Apple、Yahoo、Google和Facebook，它们没有一个当初就想成立公司，只是他们的创立者意识到了那个缺口，随着缺口的填补才然后慢慢成长起来。&lt;/p&gt;

&lt;p&gt;如果仔细研究一下那些成功的创始人获取点子的过程，就会发现结果基本就是预备好的思想受到外部的激发。Bill Gates和Paul Allen听说了Altair电脑，然后想“我们可以为这个电脑写一个Basic语言解析器”。当Drew Houston忘掉了自己的USB设备后想到“我需要将我的文件放到网上”。很多人听说了Altair电脑，也有很多人忘记了U盘。这些外部激发让这些创始人创办公司的原因是他们自己的经历已经为发现这些机会做好了准备。&lt;/p&gt;

&lt;p&gt;对于初创点子来说，最合适的动词不是“想出”，而是“发现”。在YC我们称这种能够随着创始者本人的经历自然成长的点子称为自然演进点子，最成功的初创几乎都是这种方式。&lt;/p&gt;

&lt;p&gt;这可能不是你想听到的，你可能只是希望知道一些找到初创点子的理论建议，但我却建议你成为一个准备好发现点子的人，尽管这听起来很让人灰心，但这是真理，而且可能会花掉你想当多的时间才能领悟到。&lt;/p&gt;

&lt;p&gt;如果你不是出于快速变化的领域的前沿，你可以进入一个。比如任何一个正常人可以在一年内进入编程（比如移动APP）的前沿。既然一次成功的初创将会花费三到五年的时间，一年的准备性的投资是值得的，特别当你在寻找一个合伙人的时候&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;你也没有必要非得通过学习编程从而进入变化迅速的领域前沿的编程，别的领域变化也很迅速。然而尽管学习编程不是必须的，但是对可预见的将来非常有用的。就像 Marc Andreessen所说，软件正在吞噬整个世界，这个趋势在这几十年来一直在加快。&lt;/p&gt;

&lt;p&gt;懂编程同时意味着当你有想法的时候，你可以去实现它。但这也不是必须的（Jeff Bezos就不会），但这是一个优势，尤其当你打算将一个大学Facebook上线，而不是只是想着“那是个有意思的想法”的时候，这更是个巨大的优势，那时你就会想“这个想法很不错，我可以今晚上做一个简单的版本出来”。当你既是一个程序员，又是一个用户的时候就更好了，因为这样的话，做出一个版本，然后测试，然后改进，再测试，这样的一个循环通过一个人就完成了。&lt;/p&gt;

&lt;h2 id=&#34;发现&#34;&gt;发现&lt;/h2&gt;

&lt;p&gt;如果你活在某一领域的未来，那么注意到初创点子的方法就是寻找那些看起来缺失的东西。如果你在一个变化迅速的领域的前沿，那会发现好多明显缺失的东西。所以，如果你想找到初创点子，就不能仅仅思考现在还缺哪些东西了，你应该同时不要去想任何别的东西，例如这个点子会不会成长成一个大公司等等，因为之后有很多时间去测试那些想法。但是如果你一开始就想那些东西，不仅可能过滤掉很多好点子，还会导致你将注意力放到一些坏点子上。&lt;/p&gt;

&lt;p&gt;大部分缺失的东西需要时间才能发现，你不得不让自己从观察那些身边的点子开始。&lt;/p&gt;

&lt;p&gt;你知道点子就在那儿，而且基本上你也知道该做什么。类似于科技在这一刻停滞了，你确定在接下来几年里将会出现什么新东西，你自然就会想“我应该在这之前做点什么？”&lt;/p&gt;

&lt;p&gt;当这些问题解决再去回顾时就会发现，问题解决前后明显不一样，而你所要做的就是不要让什么挡住你的视线而看不见那些问题，在这些能挡住你视线的因素中，最强大的是简单的将世界当前的状态视为理所当然的，甚至就算我们中思想最开明的人也这么做。如果你不再质疑周围，就不会发现问题。&lt;/p&gt;

&lt;p&gt;如果你正在寻找初创点子，你可以减少一些认为维持现状是理所当然的想法，开始质疑一些事情。为什么你的收件箱爆满？因为你收到了大量的邮件，或者因为很难将邮件从收件箱里清除出去？为什么你收到这么多邮件？别人想通过给你发邮件想解决什么问题吗？为什么将邮件从收件箱里清除这么困难？为什么邮件阅读之后你还要保留它们？收件箱是最理想的工具吗？&lt;/p&gt;

&lt;p&gt;考虑那些能够激怒你的事情。将现状视为理所当然的优点不只在于让当前的生活效率更高，更在于让生活更可以让人忍受。如果你了解到未来50年有但是当前还没有的情境，你会发现当前的日常生活限制相当多，就像将当前的某个人通过时光机送到50年前，当有什么事情让你不高兴，那只可能是因为你活在未来。&lt;/p&gt;

&lt;p&gt;当你找到这类的问题时，你大概能够对当前现状有不同的看法，至少对你而言。当我们开始运营viaweb时，所有的在线商店都是通过设计师手动创建的单独的HTML页面；但是对我们程序员而言，所有的这些在线商店站点都应该通过软件自动生成&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;虽然有点奇怪，但这就意味着发现初创点子其实就是看到点子完成前后明显不同的东西，这揭示了这个过程多么诡异：你知道前后明显不一样，但那个不一样的东西你又没见过。&lt;/p&gt;

&lt;p&gt;你现在需要做的就是放松你的思想，最好不要直接从正面攻击问题，例如坐下来思考这些点子。最好的计划是保心里留意查找那些看起来空缺的东西。 努力攻克那些困难但是你非常有兴趣的问题，同时注意观察周围出现的缺失造成的鸿沟和怪异之处&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;当这些出现时，记住多给你自己一些时间。你知道自己在时刻准备着发现新点子，但是你无法得知那个点子是否值得你动手。如果Bill Gates和Paul Allen在一个月内就开始实施他们初创的点子，那么在Altair电脑出现之前他们会做什么？他们可能将精力花在一个前途没有那么远大的项目上了。Drew Houston在开创DropBox之前的项目是做一个美国学术能力评估测验预备软件，但是无论从绝对意义还是与其能力匹配来说，Dropbox是一个更好的项目&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;让你时刻注意初创点子的一个好方法是做一些看起来会很酷的项目，当你试着完成这些项目的时候，你自然的就会试着去做出一些当前缺失的东西，而当去做一些已经存在的东西时就不会这样让你感兴趣了&lt;/p&gt;

&lt;p&gt;只想去想出一些初创点子经常只会得到一些不靠谱的想法，但是一些看似玩具的东西却有可能出来一些好点子。如果一个东西被认为是玩具，那就意味着除了重要性之外，这个东西拥有好点子的所有特质，例如，很酷，用户很喜欢，只是没什么影响力而已。但是如果你生活在未来你就知道一个又酷又让人喜爱的东西，它的影响力远远超过局外人的想象。当苹果和微软刚开始微型计算机方面的初创时，它还只是被看成一种玩具。我还记得这段历史，当时称呼拥有这种微型计算人为“玩具爱好者”。BackRub被认为是一个无足轻重的科研项目，而Facebook被认为只是一个在校大学生关注别人的工具而已&lt;/p&gt;

&lt;p&gt;在YC，如果一个点子被一些自称无所不知的人认为是玩具，我们是很高兴的，因为对我们来说这就是好点子的有力证明。&lt;/p&gt;

&lt;p&gt;仔细思考一下，你就会将“生活在未来，做一些当前缺失的东西”转变成更加好的一句话：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;生活在未来，做一些有趣的东西&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;学校教育&#34;&gt;学校教育&lt;/h2&gt;

&lt;p&gt;我一直建议大学去创业，不是去学着创业，创业最好通过做来学习，那些最成功的创业者的例子很好的说明了这个道理。你在大学里的时间应该花在把自己放到未来中的努力上，而且大学是完成这一步的最好机会。牺牲学习如何做一个初创企业的机会，而只是去学一些简单东西的话，这是一个多大的浪费，而且浪费的可能是一个将自己变成可以获取有成长性点子的人的机会。&lt;/p&gt;

&lt;p&gt;各个领域之间的交叉是产生大量好点子的源泉。如果你了解编程，并且你同时其它领域有所研究，你就会发现这个领域里的好多问题可以用软件解决。实际上，你会有加倍的概率在新领域里发现问题，因为：（a）新领域原来的人基本不会像可以编写软件的人那样用软件去解决问题，（b）你新进入一个领域，你不会将现状视为理所当然的。&lt;/p&gt;

&lt;p&gt;所以如果你学习的是通信专业，并且你想开始自己的初创企业，你要上的课不是关于创业的，这还不如关于遗传学的课呢，如果有机会的话去一家生物技术公司更好。通信专业的学生通常在一些电脑或者软件公司做暑假实习，但是如果你想获取一些初创点子，最好去一些非相关专业公司实习&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;或者根本不要上课，直接试着做一些东西。微软和Facebook都从一月起步，这个不是偶然现象，因为这个时间是哈佛大学的阅读期（译者注：阅读期是在每个学期末安排的八天时间，目的是让学生有整段的时间将一学期的所学进行整理总结。有期末考试的科目不会上课，而安排练习作为学期总结的课可以将最后一次练习放在这段时间。这段时间内，学生要待在学校附近），这段时间学生不需要上课&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:9&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:9&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;但是也别以为做的东西一定是个初创点子，那也要求太早了，只需要做点东西就可以了，最好可以和同学一起来做。不只是大学里的各个专业课堂可以帮你，你周围也会有很多和你有同样想法的人。如果你能与这些人一起做一些项目，你不仅可能获得一些能够茁壮成长的创始点子，同时还能组建一个能够茁壮成长的创始团队，这是最好的结果。&lt;/p&gt;

&lt;p&gt;小心那些专业学术研究。如果一个尚未毕业的学生做出一个东西并且他所有同学都很高兴使用，这就表明这是一个很好地初创点子，而相反一个博士的学术论文基本不会。一个项目越多的涉及到学术，这个项目越不可能是好点子&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:10&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;。我觉得原因可能是这样的，那些被当做学术研究的点子范围太窄，这样的项目基本上覆盖不到用户的问题。而学生（或者教授）做的副产品会自动的向解决问题方面靠近，可能需要从学术研究方面获取一点点提示而已&lt;/p&gt;

&lt;h2 id=&#34;竞争&#34;&gt;竞争&lt;/h2&gt;

&lt;p&gt;当你得到一个确实好的点子时，你可能会觉得开始的太晚了。但是不要害怕，这种担心也是一个好点子的标志。稍微在网络上搜索一下就会解决这个问题，而且就算你发现有人在和你做一样的事，一般也不会意味着太晚。很少的初创企业是因为竞争而失败的，你可以认为这种情况不会发生，所以除非你发现有竞争者占据市场并且它能够阻止你的潜在用户选择你的产品，否则不要放弃。&lt;/p&gt;

&lt;p&gt;如果你确定不了就去问问你的潜在用户。你可以询问是否有用户迫切的想要你计划的产品，如果你的产品有一些东西是竞争者没有的，并且部分用户也迫切需要这些东西，那么你就有了滩头阵地了&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;下一个问题是这个滩头阵地是否足够大，再深入一点来说就是，都有谁在这块阵地上，如果需要大量更多的人来做现在阵地上的人正在做的事，那么这个市场尽管小但也足够大了。举个例子，如果你的产品中具有和竞争对手不同的功能组件，并且这个组件是在手机上运行的，但是只有最新的手机上才能完成这个组件，如果这样的话说明阵地足够大了。&lt;/p&gt;

&lt;p&gt;面对竞争的时候好好做自己的事就可以了。缺乏经验的创始人经常高估竞争者对自己的影响。创业成功主要依赖于自己而不是竞争者，而且有竞争者的好点子总比没有竞争者的坏点子好。&lt;/p&gt;

&lt;p&gt;不要担心进入一个竞争者多如牛毛的市场，你要做好其他人忽视的那点就可以了。实际上这样的创始点子非常有前途，谷歌就是这样的典型。你关注的那一点必须要精确，不能是“我要做一个X，并且这个X不是很差”。你必须能够描述出当前的企业所忽视的东西，最好是你能够指出那些企业只是随波逐流，没有自己的洞察力，而你的计划就是做那些他们由此普遍缺乏的东西，谷歌也是这个类型。之前的搜索引擎做的事情不是搜索引擎最应该做的事情，所以他们做的越好，用户离开的越快&lt;/p&gt;

&lt;p&gt;一个产品的市场上有很多竞争者也是一个好现象，因为这意味着这一方面有需求，并且没有一个产品做得足够好。初创企业基本不可能进入一个很大但是又没有竞争者的市场，但是可以进入能够通过秘密武器将所有用户从竞争者那里抢过来的市场（就像谷歌），或者进入一个看着很小但是实际很大的市场（就像微软）&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:12&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:12&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;过滤器&#34;&gt;过滤器&lt;/h2&gt;

&lt;p&gt;如果你想发现初创点子就必须关闭两种过滤器：乏味过滤器和麻烦过滤器&lt;/p&gt;

&lt;p&gt;大部分程序员幻想着只要写出高明的代码，把这些代码部署到服务器上，然后就可以让用户付钱，然后他们的初创企业就成功了，他们不想处理那些乏味的问题，也不愿意卷进现实世界的麻烦。这些偏好可以理解，因为这些事情会将速度变慢。但是大部分人都有这些偏好，造成的结果就是简简单单就能创业成功的点子被别人抢先了。如果你能够让自己的思想能够接受处理一些乏味、单调的想法，你会发现好多很有价值的点子可以去做。&lt;/p&gt;

&lt;p&gt;麻烦过滤器非常危险，我还为此专门写了一篇关于它产生的状况的文章，我称之为麻烦式失明。我用Stripe作为例子来说明关闭麻烦过滤器的好处，这个例子很有启发。成千上万的程序员完全可以看到这个点子，同样成千上万的程序员知道在Stripe出现之前处理付款有多么痛苦。但是当他们寻找初创点子时却没有看到这个，因为他们下意识的被支付问题吓到了。对于Stripe来说，处理支付问题是有点麻烦，但是不是不能忍受。实际上Stripe相比正常来说总体上没有那么痛苦了，因为对支付问题的处理的麻烦让很多人不会参与这方面的竞争，这样Stripe在许多方面就相对来说就会相对顺利多了，例如获取用户，Stripe不需要花费大力气去宣传自己，因为用户极度渴望的他们的产品&lt;/p&gt;

&lt;p&gt;乏味过滤器和麻烦过滤器很像，只不过相对于麻烦过滤器让你害怕某些点子，乏味过滤器让你看不上某些点子。我们克服了这个问题才开发出了Viaweb。对于我们来说，编写软件有很有意思，但我们本质上对电子商务不感兴趣，尽管如此，我们意识到了这个问题并知道需要解决掉它。&lt;/p&gt;

&lt;p&gt;关掉麻烦过滤器比关掉乏味过滤器更重要，因为麻烦过滤器更能给人一种错觉，而且就算不是错觉，也比放纵自己更恶劣。建立一个初创企业本身就是很辛苦的一件事，就算产品没有那么麻烦，你仍然需要花费很大的精力处理投资问题，招聘和解雇员工问题等等，如果有一个创始点子本身很有趣，而你又不需要担心卷进麻烦的事务中，那么肯定的有多少这样的点子就有多少人来做。&lt;/p&gt;

&lt;p&gt;乏味过滤器尽管也是造成错误决定的原因，但倒是不和麻烦过滤器那样完全一无是处。如果你处于一个变化迅速的领域的前沿，那么你对点子是否很酷的评价会与实际中其价值相关联，你经验越来越丰富，这个就越明显。除此之外，你会对好不容易发现的有趣的点子投入更多的热情&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:13&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:13&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;秘方&#34;&gt;秘方&lt;/h2&gt;

&lt;p&gt;尽管说获取初创点子的方法就是将自己变成拥有点子的人，然后就可以开始自己感兴趣的事情了，但是有时你没有这个条件。经常你马上需要一个点子，比如你打算创业，但是你的点子明显不好。&lt;/p&gt;

&lt;p&gt;这篇文章剩余的部分我说一下需要点子的时候能够获得点子的诀窍。尽管从经验上来说，自然演进的策略会更好一些，但用这种方式你仍然可以成功。但你需要遵循更多的规律。当你使用自然演进方法时，知道有确切证据表明某种东西确实缺失了，你才会注意到这个点子。当你特意付出努力去想一些初创点子时，你必须用规律去替代那自然的约束。你会有很多点子，但是大部分是不好的，你需要把这些过滤掉。&lt;/p&gt;

&lt;p&gt;不使用自然方法造成的危险中最大的一个是如何排除使用自然方法成功例子的影响。自然方法产生的点子就像灵感，有很多关于初创成功的故事，这些故事中创业者们好像突然就有了个疯狂的点子，而且就知道这个点子一定会成功。然而当你想到一个点子而且也有这个感觉的时候，你可能是错的。&lt;/p&gt;

&lt;p&gt;当你研究这些点子的时候，仔细研究那些你有专业背景的领域的点子。如果你是一名数据库专家，不要选择为儿童做一款聊天工具的点子，除非你自己也是儿童。可能这是个好点子，但是你没法相信自己在那方面的判断，所以放弃这个点子。也有很多与数据库相关的点子，你也能够评价出来这些点子的质量，但是你注意到没有你很难想出与数据库相关的好点子。这是因为你的专业背景提高了你看待这些点子的标准。你之前想到的关于聊天工具的点子也不好，因为你高估了自己水平，降低了那个领域的标准。&lt;/p&gt;

&lt;p&gt;你需要找到有你真正的需求的点&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:14&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:14&#34;&gt;14&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;在YC我经常问那些创始人，“如果这个东西不是你做的你会用它吗？”，竟然很多人都回答不会】&lt;/p&gt;

&lt;p&gt;有一个很好的办法，想一想之前工作的时候，自己有没有过一种类似于“为什么没有人做过这个东西？如果有的话我马上买”的情形。如果你能想到有人说过这些类似的话，那么这个点子基本上就很好了，因为这就可以确定下来确实有人需要这个，并且一般人也不会说一些根本不可能的东西。&lt;/p&gt;

&lt;p&gt;再扩大一下范围，试着想想有没有能满足你的与周围人不一样的需求的东西。一般来说，不可能只有你自己需要这种东西，特别是如果周围人会慢慢的向这个需求靠近。&lt;/p&gt;

&lt;p&gt;当你在更改初创想法时，对你来说最与众不同的就是你之前为之奋斗的那个想法。那么你有没有发现实现那个想法时有什么需求？很多有名的初创企业就是从这里走上正轨的。hotmail的创始人觉得与同事的联系不方便，就创立了电子邮件服务&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:15&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:15&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;一个不常见但是特别有效的方法就是回到小时候，一些特别有价值的想法就是在人们十几岁或者刚过二十岁的时候出现的。因为这些年轻的初创人在某些方面的劣势，他们也特别能够真正理解他们的同龄人。如果不是大学生，你根本无法理解为什么要出现一个Facebook。所以如果你很年轻（一般不要超过23岁），那么你可以试着做一些你和你的小伙伴想做但是还没有的东西。&lt;/p&gt;

&lt;p&gt;下一个从你自身最容易发现需求的地方就是别人的需求。你可以和别人谈论当前还缺少的一些东西，他们觉得周围还缺少什么让他们觉得不好吗？如果他们没办法他们一般怎么办？他们工作中有什么无聊或者麻烦的事吗？经常这样的谈话，但是别勉强自己非得找到一个初创点子，但这些事情可能激发你有新想法。你甚至可能发现一个他们自己都没有主动意识到的问题，而这只是因为你知道怎么去解决它。&lt;/p&gt;

&lt;p&gt;当你发现一个为满足的需求时，可能一开始很模糊，因为提出需求的人不一定真正清楚他们要的是什么。碰到这种情况，我的建议是让创始人自己扮演一下咨询师的角色，如果自己被要求来解决这问题的话自己会怎么做。你们碰到的问题大体上都是相似的，所以你做的大部分工作最后都能用得上，这也总比全部做完了再去修改的代价小得多&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:16&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:16&#34;&gt;16&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;确定你的产品是否能够真正解决别人问题的方法是亲自试一下。当 Rajat Suri和Ela Carte想要为参观写软件时，他们应聘作为服务员去了解餐馆是如何运作的。这有点像走极端，但是创业本来就是走极端，当创始人这么做的时候我们也很赞成。&lt;/p&gt;

&lt;p&gt;实际上我给出的建议不仅仅是不要避开那些看起来麻烦或者不时髦的点子，而是更要主动寻找那些麻烦或者不时髦的点子。不要去学Twitter，那样的点子太稀少了，你基本上发现不了，应该做一下不时髦但是会有人愿意为之付钱的东西。&lt;/p&gt;

&lt;p&gt;有一个方法可以让你不会忽略掉那些麻烦或者某种程度上不那么时髦的点子，想一下如果别人做出了什么而你会去用，你是否愿意马上为此付钱。&lt;/p&gt;

&lt;p&gt;既然新创企业会导致很多公司或者工厂破产，那么找一下那些已经或者即将破产的公司，然后想象一下哪一类的公司会从它们的破产中受益。例如新闻业急速萎缩，但仍可以从新闻业的替代产品中赚钱，那么哪种类型的公司会被未来的人认为是新闻业这条线上的替代品呢？&lt;/p&gt;

&lt;p&gt;但是，注意，一定要处于未来的角度来做这个问题，不是基于现在的发展。通常一家公司或者工厂被替代只是从某一维度的替代。所以不要试着简单的替代现在的什么，试着去找出那些被未来证明是替代品的想法，并且注意这些替代发生的维度。例如，传统的新闻业中，读者可以从中获取信息打发时间，作者可以赚钱并吸引人的关注，还是各种类型广告的载体，这样的话，传统新闻业就可以从所有的这些维度被替代（实际上大部分已经开始了）。&lt;/p&gt;

&lt;p&gt;当初创企业蚕食老企业时，他们经常从一些很小但是很重要的市场开始，那些大企业基本上忽略了这一部分市场。如果那些大企业很看不起这部分市场就更好了，因为这部分市场经常让其走一些弯路。例如，当Steve Wozniak 造成了Apple I 的前身之后，他建议让他的下一个雇主惠普来生产。幸亏别人阻止了这个建议，其中一个原因就是惠普使用电视作为显示器，对于当时像惠普那样高大上的公司来说这反差也太大了&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:17&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:17&#34;&gt;17&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;现在有没有类似于早期微型电脑玩具玩家那样的群体？他们不修边幅但是绝对聪明，也没有被当前主流企业注意到。一个具有宏图大志的初创企业只需要付出一点不能为市场本身证明正确地努力，就通常可以非常容易的占据一个小市场。&lt;/p&gt;

&lt;p&gt;类似的，既然最成功的那些初创企业相比自身更依赖于大势，那好好的观察那些大势，并随势而动也是很好的办法。现在的基因工程和3D打印的成本正在遵循摩尔定律而不断下降，那在接下来的几年里这些新事物将会怎么影响改变世界？哪些现在看起来无法实现的东西马上会变为现实？&lt;/p&gt;

&lt;h2 id=&#34;自然演进&#34;&gt;自然演进&lt;/h2&gt;

&lt;p&gt;但是之前说到的随势而动只是获取初创点子的备用方案。遵循大势实质上只是模拟自然演进方法，如果你处于变化快速的领域的前沿，那你根本不需要找趋势，你自己就是趋势。&lt;/p&gt;

&lt;p&gt;寻找初创点子是一件很精妙的事，这就是为什么大部分人失败得很惨，只是简单的想出一些点子是不行的，如果你这样做了，你得到的一般都是听起来非常有道理的坏点子。最好的办法都不直接：如果你有某方面的正确经历，好的点子对你来说就很明显；但就算是这样，也不会是立刻就那么明显，这需要你花一段时间去经历那些能让你意识到各种缺失的情境。通常这些缺失看起来好像也不是什么创业的好点子，只是做起来很有意思罢了。这就是为什么花点时间和爱好在一些好玩的事上很有好处的原因了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;活在将来，做那些看起来有意思的东西&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;听起来很奇怪，但是这确实是诀窍&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;这种类型的坏点子在web刚出现时就有了。在90年代这个想法很常见，不过那是的人是想为什么东西建立门户网站，而不是社交网络。实际上这就是已过石头汤：你发出声明说对什么感兴趣的人都会来，然后这些人就参与进来，你就可以从他们身上赚钱了。这类的想法之所以吸引那些创始人从概率上也会有上百万的人对什么感兴趣，但是他们忘了，根据这个标准每个人都可能有20种喜好，但不能有人经常参与20多个不同的社区组织
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;顺便说一句，我不是说我确定做一个宠物设计网站就不是个好点子，但我知道随机产生的DNA不会长成好的组织器官，和这个道理是一样的。这类听起来可信的点子比好点子多得是，并且好点子甚至听起来都不可信，所以你们所有人都觉得这个点子可信，你应该判定这个点子不怎么样
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;说得再确切些，用户自身的需求会让他们有足够的动机去用你做出的东西，但这里面差别会很大。举例来说，对通过传统渠道销售的企业软件的需求动机非常强烈，所以你必须花很大力气才能让用户切换过来，但是对搜索引擎的动机就小多了，用户可以轻松切换，这也解释了为什么搜索引擎做得比企业软件的质量好的多
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;这一点随着年龄变大会越来越困难，尽管对点子的跨度没有限制，但是职业有。人类的大部分的职业都有很大的不同，年龄越大，这份不同越难以跨越
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;1995年，对于程序员来说，很明显web将会大行其道，因为这些早就在电脑桌面上得到了验证，但是非程序员就意识不到
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;可以每天晚上记录一下当天的发现，不是为了初创，只是记录下这些东西
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;Sam.Altman指出，在想到的点子上多花点时间，不仅从绝对意义来说是一个很好的策略，而且因为好少的初创者这么做，它就像被低估的股票。最好的点子之间几乎没有什么竞争，因为很少有初创者愿意花费大量时间去留心到这些点子。相反在那些平庸的点子上倒是竞争很大，因为大部分人倾向于臆造点子，这自然会产生相同的点子
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;对计算机硬件和软件公司来说，暑假实习是第一轮招聘筛选。但是如果你足够优秀，你完全可以跳过这个阶段，当你毕业的时候进入这些公司也毫无问题，这和你有没有暑假实习无关
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;经验表明，如果学校想要帮助学生开始初创，最好就是不要去管他们，让他们按照自己的想法去做&lt;br /&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:9&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;这里说的是IT方面的创始点子，在生物学方面不一样
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11&#34;&gt;有一条更通用的准则：专注于用户需求而不是竞争者。你通过用户了解到的竞争者信息是最重要的信息
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:12&#34;&gt;实际上大部分成功的初创企业有上面两个因素，你也可以通过调整你所命名市场的边界根据别的因素来描述这些策略，但是单独考虑这两个策略通常很有用
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:12&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:13&#34;&gt;对于提出这个观点我有很大的顾虑。创业是一种商业活动，商业活动的核心就是赚钱，要求点子不乏味太勉强了，因为你不可能总是能够做那些你最感兴趣的事情
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:13&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:14&#34;&gt;这个需求必须是强需求。你可以不断的将想出来的点子描述成自己想要的，但是你对一个菜谱网站或者本地新闻聚合网站的需求真的比Drew.Houston对Dropbox需求大，还是比Brian.Chesky和Joe.Gebbia对Airbnb的需求大？
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:14&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:15&#34;&gt;Paul.Buchheit指出卖一些不好的东西也有可能由此产生一些好点子，“在YC，证明点子不好的最好方法就是让这些创始人尽快去试着去销售他们的产品，而不是浪费时间去实现它们。这样的话，他们不仅能够知道他们的产品不受欢迎，而且经常的他们会在销售过程中发现真正的好点子”
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:15&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:16&#34;&gt;如果你是大学生的话，我有一个方法说不定可以创造下一个Facebook。如果你能联系上学校里最有影响力的妇女联谊会，接近她们的大姐大，做为她们的私人IT咨询师，然后做一些她们社交生活中需要但是还不存在的东西。这样做出的每个产品都很有前途，因为不仅她们本身需要这个，她们同时也是最好的推广员。但我不知道这个是否能成
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:16&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:17&#34;&gt;惠普使用电视作为显示器的原因是Steve做这个电脑是从自己的角度出发的，他和他的同辈一样买不起显示器
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:17&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>软件工程师在公司中的定位</title>
      <link>http://ssor.github.io/post/role_of_software_enginerr_in_company/</link>
      <pubDate>Mon, 13 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://ssor.github.io/post/role_of_software_enginerr_in_company/</guid>
      <description>&lt;p&gt;软件工程师应该成为公司的技术决策者&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;工程师的转型论调&#34;&gt;工程师的转型论调&lt;/h2&gt;

&lt;p&gt;一开始对这方面进行思考的驱动力是当前软件公司中工程师的发展。当前的主流论调是工程师一定要及早的转型成管理人员，比如项目经理，比如产品经理等等，依据就是年龄大了，精力不好，难以和年轻人竞争，只能退而求其次，或者依靠技术和经验的双重优势更进一步，摆脱写代码的苦逼生活；如果完成不了这种转型，那就等着慢慢完蛋吧。博客园里这类文章比较常见.&lt;/p&gt;

&lt;p&gt;有一个大致的规律,发这种文章的人一般都很年轻，如果不年轻，我发现那他一定好长时间了一直局限在做一件事（比如asp.net开发，博客园里.net技术人员挺多的），也就是，不客气的说，要么刚入这行，没有发展的热情，要么太过安逸，一直没能取得大的进步。&lt;/p&gt;

&lt;p&gt;而且,确实有许多成功的工程师,他们要么专注于技术，有了自己雄厚的资本，要么有了自己的产品，思想已经得到了升华。这些人才是得到了一些正常的软件工程师应该得到回报。&lt;/p&gt;

&lt;p&gt;成为这样的工程师，生活每天都有新鲜事物，生活富裕（前提是做出了应该的，但不是透支性的努力，当然还有热情），接触的都是特有想法的一批精英，如果再能加上产品开发的话语权，成就软件工程师的成就感，那就真的完美了。&lt;/p&gt;

&lt;h2 id=&#34;工程师在产品和公司决策中的角色&#34;&gt;工程师在产品和公司决策中的角色&lt;/h2&gt;

&lt;p&gt;工程师的生活不只是技术, 技术服务于产品, 通过技术创造让人赞叹的产品才是工程师的终极目标。但是一个普遍存在的问题就是，在公司里或者自己参与的产品里，大多数工程师只被认为是产品实现的工具, 没有话语权。这让软件工程师不怎么快乐.&lt;/p&gt;

&lt;p&gt;问题是，工程师应该具有产品和公司的话语权吗？&lt;/p&gt;

&lt;p&gt;为什么做到基业长青的公司那么稀少, 尤其是科技公司? 我们非常容易找出一些红极一时的大公司，然后几年时间，轰然倒塌，或者慢慢被初创公司慢慢赶上超越。最近的例子自然是诺基亚，当时可是谁都没想到几乎在一夜之间，诺基亚几乎沦落为三流公司；下一个可能是苹果；微软现在在下坡路上，在鲍尔默下台后，可能会有变化，但好坏不一定。google最近几十年没有问题，三星没问题，阿里暂时不会出问题，因为马云还在指引着大方向。&lt;/p&gt;

&lt;p&gt;一个被证明过多次的规律，如果一个科技公司的灵魂或者关键人物非技术背景，基本上这个公司就完了，一开始是慢慢疲软，然后不能适应变化的环境，被别的公司赶超。看诺基亚，看现在的苹果，看微软；看完了这个再看google，看facebook。阿里比较特殊，但阿里除了马云, 还有一系列早期的技术元老在默默推动着阿里的进步, 这也是阿里成为能在国际技术舞台上重要角色的基础. 乔布斯是人性和技术两方面的集大成者，他能看透人心，也对技术有深刻的理解。&lt;/p&gt;

&lt;p&gt;为什么会是这样呢？因为一旦非技术人物占据了公司的关键位置，这些管理者就会按照管理的思路去运作公司，管理类的人会更快得到晋升，掌握公司发展的话语权；问题在于，这些人由于对技术理解不够深厚，目光短浅，在产品布局方面，要么是错误的，要么是跟风的，永远不会是引领者。苹果迎来巅峰是因为苹果在引领世界，android占据一半多的移动市场是N年前的布局，对照鲜明的是微软的亦步亦趋。乔布斯说的那句话很对，微软善于捕捉机会（那是比尔盖茨还在的时候），它的成功都是用勤奋换来的。如果说比尔盖茨在的时候还有捕捉机会的优势，那现在我们唯一能看到的只有一点点勤奋了。&lt;/p&gt;

&lt;p&gt;这背后深层次的理论依据就是不同领域的事应该交给不同领域的人去做决策。&lt;/p&gt;

&lt;p&gt;公司的招标投标运营管理交给公司市场部去打理，但是产品的开发进度交由开发人员来决定进度吧，那些所谓的管理者来决定今天应该写几行代码就是天大的笑话。&lt;/p&gt;

&lt;p&gt;开发一套系统或者一个产品，深处其中的开发人员最能了解里面的枝节，他们知道那一部分大约消耗多长时间能做到什么程度，他们知道目前的技术架构存在什么隐患，他们知道加班能加快进度到什么程度；那些管理者知道什么呢？一个不是这行的人怎么会了解这个功能可能一年都做不好，而不是管理者觉得的一星期就能完成？&lt;/p&gt;

&lt;p&gt;最近挺火的那部视频 遗失的访谈中，乔布斯谈到，开发一个新产品要把5000个问题放到脑子里，然后不断的思考，与现实妥协，然后整理出一个可行的发展思路，想法和时间的间隔可以用天堑来形容，只能慢慢靠近最终的想法，这些放在那些管理者的脑子里就会觉得雇佣几个人搞定就成了。所以乔布斯临死前将IPhone设计到了iphone5，再看看现在的苹果，他们已经不知所措了，不知道下一步应该做什么了，他们已经开始在研究三星下一步做什么了，所以我说，苹果说不定就会是下一个诺基亚，当然，有乔布斯的遗产在，不会那么像，但也只是将时间拖长的诺基亚。&lt;/p&gt;

&lt;p&gt;软件工程师的发展道路，工程师不是一定非得写代码（其实一个产品不需要每天写那么多代码）, 工程师也应该有自己的哲学，有自己的审美，有自己的设计，有自己的事业，有自己的追求。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>